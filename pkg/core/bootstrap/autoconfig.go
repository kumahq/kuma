package bootstrap

import (
	"io/ioutil"
	"os"
	"strings"

	"github.com/pkg/errors"

	kuma_cp "github.com/kumahq/kuma/pkg/config/app/kuma-cp"
	config_core "github.com/kumahq/kuma/pkg/config/core"
	dp_server "github.com/kumahq/kuma/pkg/config/dp-server"
	"github.com/kumahq/kuma/pkg/core"
	"github.com/kumahq/kuma/pkg/tls"
	util_net "github.com/kumahq/kuma/pkg/util/net"
)

var autoconfigureLog = core.Log.WithName("bootstrap").WithName("auto-configure")

func autoconfigure(cfg *kuma_cp.Config) error {
	autoconfigureDpServerAuth(cfg)
	if err := autoconfigureTLS(cfg); err != nil {
		return errors.Wrap(err, "could not autogenerate TLS certificate")
	}
	autoconfigureServersTLS(cfg)
	autoconfigBootstrapXdsParams(cfg)
	return nil
}

func autoconfigureDpServerAuth(cfg *kuma_cp.Config) {
	if cfg.DpServer.Auth.Type == "" {
		switch cfg.Environment {
		case config_core.KubernetesEnvironment:
			cfg.DpServer.Auth.Type = dp_server.DpServerAuthServiceAccountToken
		case config_core.UniversalEnvironment:
			cfg.DpServer.Auth.Type = dp_server.DpServerAuthDpToken
		}
	}
}

func autoconfigureServersTLS(cfg *kuma_cp.Config) {
	if cfg.Multizone.Global.KDS.TlsCertFile == "" {
		cfg.Multizone.Global.KDS.TlsCertFile = cfg.General.TlsCertFile
		cfg.Multizone.Global.KDS.TlsKeyFile = cfg.General.TlsKeyFile
	}
	if cfg.DpServer.TlsCertFile == "" {
		cfg.DpServer.TlsCertFile = cfg.General.TlsCertFile
		cfg.DpServer.TlsKeyFile = cfg.General.TlsKeyFile
	}
	if cfg.ApiServer.HTTPS.TlsCertFile == "" {
		cfg.ApiServer.HTTPS.TlsCertFile = cfg.General.TlsCertFile
		cfg.ApiServer.HTTPS.TlsKeyFile = cfg.General.TlsKeyFile
	}
}

func autoconfigureTLS(cfg *kuma_cp.Config) error {
	if cfg.General.TlsCertFile == "" {
		ips, err := util_net.GetAllIPs()
		if err != nil {
			return errors.Wrap(err, "could not list all IPs of the machine")
		}
		hostname, err := os.Hostname()
		if err != nil {
			return errors.Wrap(err, "could not get a hostname of the machine")
		}
		hosts := append([]string{hostname, "localhost"}, ips...)
		cert, err := tls.NewSelfSignedCert("kuma-control-plane", tls.ServerCertType, hosts...)
		if err != nil {
			return errors.Wrap(err, "failed to auto-generate TLS certificate")
		}
		crtFile, keyFile, err := saveKeyPair(cert)
		if err != nil {
			return errors.Wrap(err, "failed to save auto-generated TLS certificate")
		}
		cfg.General.TlsCertFile = crtFile
		cfg.General.TlsKeyFile = keyFile
		autoconfigureLog.Info("TLS certificate autogenerated. Autogenerated certificates are not synchronized between CP instances. It is only valid if the data plane proxy connects to the CP by one of the following address "+strings.Join(hosts, ", ")+
			". It is recommended to generate your own certificate based on yours trusted CA. You can also generate your own self-signed certificates using 'kumactl generate tls-certificate --type=server --cp-hostname=<hostname>' and configure them using KUMA_GENERAL_TLS_CERT_FILE and KUMA_GENERAL_TLS_KEY_FILE", "crtFile", crtFile, "keyFile", keyFile)
	}
	return nil
}

func autoconfigBootstrapXdsParams(cfg *kuma_cp.Config) {
	if cfg.BootstrapServer.Params.XdsPort == 0 {
		cfg.BootstrapServer.Params.XdsPort = uint32(cfg.DpServer.Port)
	}
}

func saveKeyPair(pair tls.KeyPair) (string, string, error) {
	crtFile, err := ioutil.TempFile("", "*.crt")
	if err != nil {
		return "", "", errors.Wrap(err, "failed to create a temp file with TLS cert")
	}
	if err := ioutil.WriteFile(crtFile.Name(), pair.CertPEM, os.ModeTemporary); err != nil {
		return "", "", errors.Wrapf(err, "failed to save TLS cert into a temp file %q", crtFile.Name())
	}

	keyFile, err := ioutil.TempFile("", "*.key")
	if err != nil {
		return "", "", errors.Wrap(err, "failed to create a temp file with TLS key")
	}
	if err := ioutil.WriteFile(keyFile.Name(), pair.KeyPEM, os.ModeTemporary); err != nil {
		return "", "", errors.Wrapf(err, "failed to save TLS key into a temp file %q", keyFile.Name())
	}

	return crtFile.Name(), keyFile.Name(), nil
}
