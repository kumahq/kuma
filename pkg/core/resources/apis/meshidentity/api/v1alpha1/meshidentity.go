// +kubebuilder:object:generate=true
package v1alpha1

import (
	k8s "k8s.io/apimachinery/pkg/apis/meta/v1"

	common_api "github.com/kumahq/kuma/api/common/v1alpha1"
	datasource_api "github.com/kumahq/kuma/api/common/v1alpha1/datasource"
)

type Selector struct {
	Dataplane *common_api.LabelSelector `json:"dataplane,omitempty"`
}

// MeshIdentity
// +kuma:policy:is_policy=false
// +kuma:policy:has_status=true
// +kuma:policy:allowed_on_system_namespace_only=true
// +kuma:policy:short_name=mid
// +kuma:policy:kds_flags=model.GlobalToZonesFlag | model.ZoneToGlobalFlag
// +kuma:policy:register_generator=true
type MeshIdentity struct {
	Selector *Selector `json:"selector,omitempty"`
	SpiffeID *SpiffeID `json:"spiffeID,omitempty"`
	Provider Provider  `json:"provider"`
}

type SpiffeID struct {
	TrustDomain *string `json:"trustDomain,omitempty"`
	Path        *string `json:"path,omitempty"`
}

// +kubebuilder:validation:Enum=Bundled;Spire
type ProviderType string

const (
	BundledType ProviderType = "Bundled"
	SpireType   ProviderType = "Spire"
)

type Provider struct {
	// Type specifies the type of certificate provider.
	// +required
	// +kubebuilder:validation:Required
	Type ProviderType `json:"type"`
	// Bundled provides information about certificates that are generated by the control plane,
	// either autogenerated or provided by the user.
	Bundled *Bundled `json:"bundled,omitempty"`
	// Spire indicates that SPIRE is used for certificate delivery.
	Spire *Spire `json:"spire,omitempty"`
}

type CertificateParameters struct {
	Expiry *k8s.Duration `json:"expiry,omitempty"`
}

// +kubebuilder:validation:Enum=Enabled;Disabled
type MeshTrustCreationMode string

const (
	MeshTrustCreationEnabled  MeshTrustCreationMode = "Enabled"
	MeshTrustCreationDisabled MeshTrustCreationMode = "Disabled"
)

type Autogenerate struct {
	Enabled *bool `json:"enabled,omitempty"`
}

type Bundled struct {
	// MeshTrustCreation defines whether a MeshTrust resource should be automatically created
	// from an existing MeshIdentity. If not defined, the control plane automatically generates a MeshTrust.
	MeshTrustCreation *MeshTrustCreationMode `json:"meshTrustCreation,omitempty"`
	// InsecureAllowSelfSigned allows users to enable the use of self-signed certificates.
	InsecureAllowSelfSigned *bool `json:"insecureAllowSelfSigned,omitempty"`
	// Autogenerate configures the control plane to use self-signed certificates.
	Autogenerate *Autogenerate `json:"autogenerate,omitempty"`
	// CA has configuration related to the CA
	CA *CA `json:"ca,omitempty"`
	// CertificateParameters allows users to define certificate generation parameters.
	CertificateParameters *CertificateParameters `json:"certificateParameters,omitempty"`
}

type CA struct {
	// Certificate allows the user to specify a custom certificate.
	Certificate *datasource_api.SecureDataSource `json:"certificate,omitempty"`
	// PrivateKey allows the user to specify a custom private key.
	PrivateKey *datasource_api.SecureDataSource `json:"privateKey,omitempty"`
}

type SpireAgent struct {
	// Connection timeout to the socket exposed by Spire agent
	// Default 1 second.
	Timeout *k8s.Duration `json:"timeout,omitempty"`
}

type Spire struct {
	// Spire agent configuration
	Agent *SpireAgent `json:"agent,omitempty"`
}

const (
	ReadyConditionType     string = "Ready"
	ProviderConditionType  string = "Provider"
	MeshTrustConditionType string = "MeshTrustCreated"
)

type MeshIdentityStatus struct {
	// Conditions is an array of hostname generator conditions.
	//
	// +optional
	// +patchMergeKey=type
	// +patchStrategy=merge
	// +listType=map
	// +listMapKey=type
	Conditions []common_api.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type"`
}
