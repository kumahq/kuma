package v1alpha1

import (
	"text/template"

	"github.com/pkg/errors"

	"github.com/kumahq/kuma/pkg/core/validators"
	"github.com/kumahq/kuma/pkg/util/pointer"
)

func (r *MeshIdentityResource) validate() error {
	var verr validators.ValidationError
	path := validators.RootedAt("spec")
	verr.AddErrorAt(path.Field("spiffeID"), validateSPIFFEID(pointer.Deref(r.Spec.SpiffeID)))
	verr.AddErrorAt(path.Field("provider"), validateProvider(r.Spec.Provider))
	return verr.OrNil()
}

func validateSPIFFEID(spiffeID SpiffeID) validators.ValidationError {
	var verr validators.ValidationError
	if pointer.Deref(spiffeID.TrustDomain) != "" {
		_, err := template.New("").
			Funcs(map[string]any{"label": func(key string) (string, error) { return "", nil }}).
			Parse(pointer.Deref(spiffeID.TrustDomain))
		if err != nil {
			verr.AddViolation("trustDomain", errors.Wrap(err, "couldn't parse template").Error())
		}
	}
	if pointer.Deref(spiffeID.Path) != "" {
		_, err := template.New("").
			Funcs(map[string]any{"label": func(key string) (string, error) { return "", nil }}).
			Parse(pointer.Deref(spiffeID.TrustDomain))
		if err != nil {
			verr.AddViolation("path", errors.Wrap(err, "couldn't parse template").Error())
		}
	}
	return verr
}

func validateProvider(provider Provider) validators.ValidationError {
	var verr validators.ValidationError
	switch provider.Type {
	case BundledType:
		verr.Add(validateBundled(validators.RootedAt("bundled"), provider.Bundled))
	case SpireType:
		verr.Add(validateSpire(validators.RootedAt("spire"), provider.Spire))
	default:
		verr.AddError("type", validators.MakeFieldMustBeOneOfErr(string(provider.Type), string(BundledType), string(SpireType)))
	}
	return verr
}

func validateBundled(path validators.PathBuilder, b *Bundled) validators.ValidationError {
	var verr validators.ValidationError
	if b == nil {
		verr.AddViolationAt(path, "configuration needs to be defined")
		return verr
	}
	if b.MeshTrustCreation != nil {
		switch *b.MeshTrustCreation {
		case MeshTrustCreationEnabled:
		case MeshTrustCreationDisabled:
		default:
			verr.AddErrorAt(
				path.Field("meshTrustCreation"),
				validators.MakeFieldMustBeOneOfErr(string(*b.MeshTrustCreation), string(MeshTrustCreationEnabled), string(MeshTrustCreationDisabled)),
			)
		}
	}
	if b.Autogenerate != nil && pointer.Deref(b.Autogenerate.Enabled) {
		if b.CA != nil {
			verr.AddViolationAt(path.Field("ca"), "shouldn't be defined once using autogenerated")
		}
	} else {
		if b.CA == nil {
			verr.AddViolationAt(path.Field("ca"), "needs to be defined")
		} else {
			if b.CA.Certificate == nil {
				verr.AddViolationAt(path.Field("ca").Field("certificate"), "needs to be defined")
			} else {
				verr.Add(b.CA.Certificate.ValidateSecureDataSource(path.Field("ca").Field("certificate")))
			}
			if b.CA.PrivateKey == nil {
				verr.AddViolationAt(path.Field("ca").Field("privateKey"), "needs to be defined")
			} else {
				verr.Add(b.CA.PrivateKey.ValidateSecureDataSource(path.Field("ca").Field("privateKey")))
			}
		}
	}
	if b.CertificateParameters != nil {
		if b.CertificateParameters.Expiry != nil {
			verr.Add(validators.ValidateDurationNotNegative(path.Field("certificateParameters").Field("expiry"), b.CertificateParameters.Expiry))
		}
	}
	return verr
}

func validateSpire(path validators.PathBuilder, b *Spire) validators.ValidationError {
	var verr validators.ValidationError
	if b == nil {
		verr.AddViolationAt(path, "configuration needs to be defined")
		return verr
	}
	if b.Agent != nil {
		verr.AddErrorAt(path.Field("agent"), validateSpireAgent(path.Field("agent"), b.Agent))
	}
	return verr
}

func validateSpireAgent(path validators.PathBuilder, b *SpireAgent) validators.ValidationError {
	return validators.ValidateDurationNotNegativeOrNil(path.Field("timeout"), b.Timeout)
}
