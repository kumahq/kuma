package bundled_test

import (
	"context"
	"crypto/x509"
	"encoding/pem"
	"time"

	envoy_auth "github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3"
	envoy_resource "github.com/envoyproxy/go-control-plane/pkg/resource/v3"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"

	"github.com/kumahq/kuma/api/common/v1alpha1"
	mesh_proto "github.com/kumahq/kuma/api/mesh/v1alpha1"
	"github.com/kumahq/kuma/pkg/core"
	"github.com/kumahq/kuma/pkg/core/kri"
	core_mesh "github.com/kumahq/kuma/pkg/core/resources/apis/mesh"
	"github.com/kumahq/kuma/pkg/core/resources/apis/meshidentity/providers"
	"github.com/kumahq/kuma/pkg/core/resources/apis/meshidentity/providers/bundled"
	core_system "github.com/kumahq/kuma/pkg/core/resources/apis/system"
	"github.com/kumahq/kuma/pkg/core/resources/manager"
	"github.com/kumahq/kuma/pkg/core/resources/model"
	core_store "github.com/kumahq/kuma/pkg/core/resources/store"
	"github.com/kumahq/kuma/pkg/core/secrets/cipher"
	secret_manager "github.com/kumahq/kuma/pkg/core/secrets/manager"
	"github.com/kumahq/kuma/pkg/core/secrets/store"
	core_xds "github.com/kumahq/kuma/pkg/core/xds"
	bldrs_core "github.com/kumahq/kuma/pkg/envoy/builders/core"
	bldrs_tls "github.com/kumahq/kuma/pkg/envoy/builders/tls"
	core_metrics "github.com/kumahq/kuma/pkg/metrics"
	"github.com/kumahq/kuma/pkg/plugins/resources/memory"
	"github.com/kumahq/kuma/pkg/plugins/runtime/k8s/metadata"
	"github.com/kumahq/kuma/pkg/test/resources/builders"
	xds_builders "github.com/kumahq/kuma/pkg/test/xds/builders"
	"github.com/kumahq/kuma/pkg/xds/generator/system_names"
)

var _ = Describe("Bundled Providers Test", func() {
	var secretManager manager.ResourceManager
	var resourceManager manager.ResourceManager
	var mesh *core_mesh.MeshResource
	var metrics core_metrics.Metrics
	var bundledProvider providers.IdentityProvider

	now := time.Now()

	BeforeEach(func() {
		core.Now = func() time.Time {
			return now
		}
		memoryStore := memory.NewStore()
		resourceManager = manager.NewResourceManager(memoryStore)
		secretManager = secret_manager.NewSecretManager(store.NewSecretStore(memoryStore), cipher.None(), nil, false)
		mesh = core_mesh.NewMeshResource()
		// Since mesh is the owner of secrets we can't operate on secrets without having the mesh in the store
		err := resourceManager.Create(context.Background(), mesh, core_store.CreateByKey(model.DefaultMesh, model.NoMesh))
		Expect(err).ToNot(HaveOccurred())

		metrics, err = core_metrics.NewMetrics("")
		Expect(err).ToNot(HaveOccurred())

		bundledProvider, err = bundled.NewBundledIdentityProvider(secretManager, secretManager, metrics, "my-zone")
		Expect(err).ToNot(HaveOccurred())
	})

	AfterEach(func() {
		core.Now = time.Now
	})

	Context("Initialize", func() {
		It("should create autogenerated CA", func() {
			meshIdentity := builders.MeshIdentity().
				WithName("matching-1").
				WithSelector(&v1alpha1.LabelSelector{
					MatchLabels: &map[string]string{
						"app":     "test-app",
						"version": "v1",
					},
				}).WithBundledAutoGenerated().Build()
			// create MeshIdentity
			Expect(resourceManager.Create(context.TODO(), meshIdentity, core_store.CreateBy(model.MetaToResourceKey(meshIdentity.Meta)))).To(Succeed())

			// when
			err := bundledProvider.Initialize(context.TODO(), meshIdentity)

			// then
			Expect(err).ToNot(HaveOccurred())

			ca := core_system.NewSecretResource()
			Expect(secretManager.Get(context.TODO(), ca, core_store.GetByKey(bundled.RootCAName(model.GetDisplayName(meshIdentity.GetMeta())), meshIdentity.Meta.GetMesh()))).To(Succeed())
			Expect(ca.Spec.Data.GetValue()).ToNot(BeEmpty())

			privateKey := core_system.NewSecretResource()
			Expect(secretManager.Get(context.TODO(), privateKey, core_store.GetByKey(bundled.PrivateKeyName(model.GetDisplayName(meshIdentity.GetMeta())), meshIdentity.Meta.GetMesh()))).To(Succeed())
			Expect(privateKey.Spec.Data.GetValue()).ToNot(BeEmpty())
		})

		It("should not create autogenerated CA", func() {
			meshIdentity := builders.MeshIdentity().
				WithName("matching-1").
				WithSelector(&v1alpha1.LabelSelector{
					MatchLabels: &map[string]string{
						"app":     "test-app",
						"version": "v1",
					},
				}).WithBundled().Build()
			// create MeshIdentity
			Expect(resourceManager.Create(context.TODO(), meshIdentity, core_store.CreateBy(model.MetaToResourceKey(meshIdentity.Meta)))).To(Succeed())

			// when
			err := bundledProvider.Initialize(context.TODO(), meshIdentity)

			// then
			Expect(err).ToNot(HaveOccurred())

			ca := core_system.NewSecretResource()
			err = secretManager.Get(context.TODO(), ca, core_store.GetByKey(bundled.RootCAName(model.GetDisplayName(meshIdentity.GetMeta())), meshIdentity.Meta.GetMesh()))
			Expect(core_store.IsNotFound(err)).To(BeTrue())
		})
	})

	Context("Validate", func() {
		It("should validate that autogenerated certificate is self-signed", func() {
			meshIdentity := builders.MeshIdentity().
				WithName("matching-1").
				WithSelector(&v1alpha1.LabelSelector{
					MatchLabels: &map[string]string{
						"app":     "test-app",
						"version": "v1",
					},
				}).WithBundledAutoGenerated().NotSelfSigned().Build()
			// create MeshIdentity
			Expect(resourceManager.Create(context.TODO(), meshIdentity, core_store.CreateBy(model.MetaToResourceKey(meshIdentity.Meta)))).To(Succeed())

			// when
			err := bundledProvider.Initialize(context.TODO(), meshIdentity)
			Expect(err).ToNot(HaveOccurred())

			// and
			err = bundledProvider.Validate(context.TODO(), meshIdentity)

			// then
			Expect(err).To(HaveOccurred())
			Expect(err.Error()).To(ContainSubstring("self-signed certificates are not allowed"))
		})
	})

	Context("CreateIdentity", func() {
		It("should provide a identity for a dataplane", func() {
			meshIdentity := builders.MeshIdentity().
				WithName("matching-1").
				WithSelector(&v1alpha1.LabelSelector{
					MatchLabels: &map[string]string{
						"app":     "test-app",
						"version": "v1",
					},
				}).WithBundledAutoGenerated().Build()

			expectedIdentity, err := bldrs_tls.NewTlsCertificateSdsSecretConfigs().Configure(
				bldrs_tls.SdsSecretConfigSource(
					kri.From(meshIdentity).String(),
					bldrs_core.NewConfigSource().Configure(bldrs_core.Sds()),
				),
			).Build()
			Expect(err).ToNot(HaveOccurred())
			expectedValidation, err := bldrs_tls.NewTlsCertificateSdsSecretConfigs().Configure(
				bldrs_tls.SdsSecretConfigSource(
					system_names.SystemResourceNameCABundle,
					bldrs_core.NewConfigSource().Configure(bldrs_core.Sds()),
				),
			).Build()
			Expect(err).ToNot(HaveOccurred())

			// create MeshIdentity
			Expect(resourceManager.Create(context.TODO(), meshIdentity, core_store.CreateBy(model.MetaToResourceKey(meshIdentity.Meta)))).To(Succeed())

			// when
			err = bundledProvider.Initialize(context.TODO(), meshIdentity)
			Expect(err).ToNot(HaveOccurred())

			proxy := xds_builders.Proxy().
				WithDataplane(builders.Dataplane().
					WithName("web-01").
					WithAddress("192.168.0.2").
					WithLabels(map[string]string{
						metadata.KumaServiceAccount: "my-sa",
						mesh_proto.KubeNamespaceTag: "my-ns",
					}).
					WithInboundOfTags(mesh_proto.ServiceTag, "web", mesh_proto.ProtocolTag, "http")).
				Build()

			// create identity
			identity, err := bundledProvider.CreateIdentity(context.TODO(), meshIdentity, proxy)

			// then
			Expect(err).ToNot(HaveOccurred())
			Expect(identity.KRI).To(Equal(kri.From(meshIdentity)))

			identitySource, err := bldrs_tls.NewTlsCertificateSdsSecretConfigs().Configure(identity.IdentitySourceConfigurer()).Build()
			Expect(err).ToNot(HaveOccurred())
			Expect(identitySource).To(Equal(expectedIdentity))

			validatorSource, err := bldrs_tls.NewTlsCertificateSdsSecretConfigs().Configure(identity.ValidationSourceConfigurer()).Build()
			Expect(err).ToNot(HaveOccurred())
			Expect(validatorSource).To(Equal(expectedValidation))

			// secrets are also created
			Expect(identity.AdditionalResources.Resources(envoy_resource.SecretType)).To(HaveKey(kri.From(meshIdentity).String()))

			cert, err := readCertificate(identity, kri.From(meshIdentity).String())
			Expect(err).ToNot(HaveOccurred())
			Expect(cert.URIs).To(HaveLen(1))
			Expect(cert.URIs[0].String()).To(Equal("spiffe://default.my-zone.mesh.local/ns/my-ns/sa/my-sa"))
		})
	})
})

func readCertificate(identity *core_xds.WorkloadIdentity, kri string) (*x509.Certificate, error) {
	secrets := identity.AdditionalResources.Resources(envoy_resource.SecretType)
	secret := secrets[kri].Resource.(*envoy_auth.Secret)
	certificate := secret.GetTlsCertificate().CertificateChain.GetInlineBytes()
	// Decode PEM block
	block, _ := pem.Decode(certificate)
	if block == nil || block.Type != "CERTIFICATE" {
		panic("failed to decode PEM block containing certificate")
	}

	// Parse the certificate
	return x509.ParseCertificate(block.Bytes)
}
