package bundled_test

import (
	"context"
	"crypto/x509"
	"encoding/pem"
	"time"

	envoy_auth "github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3"
	envoy_resource "github.com/envoyproxy/go-control-plane/pkg/resource/v3"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"

	"github.com/kumahq/kuma/v2/api/common/v1alpha1"
	mesh_proto "github.com/kumahq/kuma/v2/api/mesh/v1alpha1"
	"github.com/kumahq/kuma/v2/pkg/core"
	"github.com/kumahq/kuma/v2/pkg/core/kri"
	core_mesh "github.com/kumahq/kuma/v2/pkg/core/resources/apis/mesh"
	"github.com/kumahq/kuma/v2/pkg/core/resources/apis/meshidentity/providers"
	"github.com/kumahq/kuma/v2/pkg/core/resources/apis/meshidentity/providers/bundled"
	core_system "github.com/kumahq/kuma/v2/pkg/core/resources/apis/system"
	"github.com/kumahq/kuma/v2/pkg/core/resources/manager"
	"github.com/kumahq/kuma/v2/pkg/core/resources/model"
	core_store "github.com/kumahq/kuma/v2/pkg/core/resources/store"
	"github.com/kumahq/kuma/v2/pkg/core/secrets/cipher"
	secret_manager "github.com/kumahq/kuma/v2/pkg/core/secrets/manager"
	"github.com/kumahq/kuma/v2/pkg/core/secrets/store"
	core_xds "github.com/kumahq/kuma/v2/pkg/core/xds"
	bldrs_core "github.com/kumahq/kuma/v2/pkg/envoy/builders/core"
	bldrs_tls "github.com/kumahq/kuma/v2/pkg/envoy/builders/tls"
	core_metrics "github.com/kumahq/kuma/v2/pkg/metrics"
	"github.com/kumahq/kuma/v2/pkg/plugins/resources/memory"
	"github.com/kumahq/kuma/v2/pkg/plugins/runtime/k8s/metadata"
	"github.com/kumahq/kuma/v2/pkg/test/resources/builders"
	xds_builders "github.com/kumahq/kuma/v2/pkg/test/xds/builders"
)

var _ = Describe("Bundled Providers Test", func() {
	var secretManager manager.ResourceManager
	var resourceManager manager.ResourceManager
	var mesh *core_mesh.MeshResource
	var metrics core_metrics.Metrics
	var bundledProvider providers.IdentityProvider

	now := time.Now()

	BeforeEach(func() {
		core.Now = func() time.Time {
			return now
		}
		memoryStore := memory.NewStore()
		resourceManager = manager.NewResourceManager(memoryStore)
		secretManager = secret_manager.NewSecretManager(store.NewSecretStore(memoryStore), cipher.None(), nil, false)
		mesh = core_mesh.NewMeshResource()
		// Since mesh is the owner of secrets we can't operate on secrets without having the mesh in the store
		err := resourceManager.Create(context.Background(), mesh, core_store.CreateByKey(model.DefaultMesh, model.NoMesh))
		Expect(err).ToNot(HaveOccurred())

		metrics, err = core_metrics.NewMetrics("")
		Expect(err).ToNot(HaveOccurred())

		bundledProvider, err = bundled.NewBundledIdentityProvider(secretManager, secretManager, metrics, "my-zone")
		Expect(err).ToNot(HaveOccurred())
	})

	AfterEach(func() {
		core.Now = time.Now
	})

	Context("Initialize", func() {
		It("should create autogenerated CA", func() {
			meshIdentity := builders.MeshIdentity().
				WithName("matching-1").
				WithSelector(&v1alpha1.LabelSelector{
					MatchLabels: &map[string]string{
						"app":     "test-app",
						"version": "v1",
					},
				}).WithBundledAutoGenerated().Build()
			// create MeshIdentity
			Expect(resourceManager.Create(context.TODO(), meshIdentity, core_store.CreateBy(model.MetaToResourceKey(meshIdentity.Meta)))).To(Succeed())

			// when
			err := bundledProvider.Initialize(context.TODO(), meshIdentity)

			// then
			Expect(err).ToNot(HaveOccurred())

			ca := core_system.NewSecretResource()
			Expect(secretManager.Get(context.TODO(), ca, core_store.GetByKey(bundled.RootCAName(model.GetDisplayName(meshIdentity.GetMeta())), meshIdentity.Meta.GetMesh()))).To(Succeed())
			Expect(ca.Spec.Data.GetValue()).ToNot(BeEmpty())

			privateKey := core_system.NewSecretResource()
			Expect(secretManager.Get(context.TODO(), privateKey, core_store.GetByKey(bundled.PrivateKeyName(model.GetDisplayName(meshIdentity.GetMeta())), meshIdentity.Meta.GetMesh()))).To(Succeed())
			Expect(privateKey.Spec.Data.GetValue()).ToNot(BeEmpty())
		})

		It("should not create autogenerated CA", func() {
			meshIdentity := builders.MeshIdentity().
				WithName("matching-1").
				WithSelector(&v1alpha1.LabelSelector{
					MatchLabels: &map[string]string{
						"app":     "test-app",
						"version": "v1",
					},
				}).WithBundled().Build()
			// create MeshIdentity
			Expect(resourceManager.Create(context.TODO(), meshIdentity, core_store.CreateBy(model.MetaToResourceKey(meshIdentity.Meta)))).To(Succeed())

			// when
			err := bundledProvider.Initialize(context.TODO(), meshIdentity)

			// then
			Expect(err).ToNot(HaveOccurred())

			ca := core_system.NewSecretResource()
			err = secretManager.Get(context.TODO(), ca, core_store.GetByKey(bundled.RootCAName(model.GetDisplayName(meshIdentity.GetMeta())), meshIdentity.Meta.GetMesh()))
			Expect(core_store.IsNotFound(err)).To(BeTrue())
		})
	})

	Context("Validate", func() {
		It("should validate that autogenerated certificate is self-signed", func() {
			meshIdentity := builders.MeshIdentity().
				WithName("matching-1").
				WithSelector(&v1alpha1.LabelSelector{
					MatchLabels: &map[string]string{
						"app":     "test-app",
						"version": "v1",
					},
				}).WithBundledAutoGenerated().NotSelfSigned().Build()
			// create MeshIdentity
			Expect(resourceManager.Create(context.TODO(), meshIdentity, core_store.CreateBy(model.MetaToResourceKey(meshIdentity.Meta)))).To(Succeed())

			// when
			err := bundledProvider.Initialize(context.TODO(), meshIdentity)
			Expect(err).ToNot(HaveOccurred())

			// and
			err = bundledProvider.Validate(context.TODO(), meshIdentity)

			// then
			Expect(err).To(HaveOccurred())
			Expect(err.Error()).To(ContainSubstring("self-signed certificates are not allowed"))
		})
	})

	Context("CreateIdentity", func() {
		It("should provide a identity for a dataplane", func() {
			meshIdentity := builders.MeshIdentity().
				WithName("matching-1").
				WithSelector(&v1alpha1.LabelSelector{
					MatchLabels: &map[string]string{
						"app":     "test-app",
						"version": "v1",
					},
				}).WithBundledAutoGenerated().Build()

			expectedIdentity, err := bldrs_tls.NewTlsCertificateSdsSecretConfigs().Configure(
				bldrs_tls.SdsSecretConfigSource(
					kri.From(meshIdentity).String(),
					bldrs_core.NewConfigSource().Configure(bldrs_core.Sds()),
				),
			).Build()
			Expect(err).ToNot(HaveOccurred())

			// create MeshIdentity
			Expect(resourceManager.Create(context.TODO(), meshIdentity, core_store.CreateBy(model.MetaToResourceKey(meshIdentity.Meta)))).To(Succeed())

			// when
			err = bundledProvider.Initialize(context.TODO(), meshIdentity)
			Expect(err).ToNot(HaveOccurred())

			proxy := xds_builders.Proxy().
				WithDataplane(builders.Dataplane().
					WithName("web-01").
					WithAddress("192.168.0.2").
					WithLabels(map[string]string{
						metadata.KumaServiceAccount: "my-sa",
						mesh_proto.KubeNamespaceTag: "my-ns",
					}).
					WithInboundOfTags(mesh_proto.ServiceTag, "web", mesh_proto.ProtocolTag, "http")).
				Build()

			// create identity
			identity, err := bundledProvider.CreateIdentity(context.TODO(), meshIdentity, proxy)

			// then
			Expect(err).ToNot(HaveOccurred())
			Expect(identity.KRI).To(Equal(kri.From(meshIdentity)))

			identitySource, err := bldrs_tls.NewTlsCertificateSdsSecretConfigs().Configure(identity.IdentitySourceConfigurer()).Build()
			Expect(err).ToNot(HaveOccurred())
			Expect(identitySource).To(Equal(expectedIdentity))

			// secrets are also created
			Expect(identity.AdditionalResources.Resources(envoy_resource.SecretType)).To(HaveKey(kri.From(meshIdentity).String()))

			cert, err := readCertificate(identity, kri.From(meshIdentity).String())
			Expect(err).ToNot(HaveOccurred())
			Expect(cert.URIs).To(HaveLen(1))
			Expect(cert.URIs[0].String()).To(Equal("spiffe://default.my-zone.mesh.local/ns/my-ns/sa/my-sa"))
		})

		It("should use different CA pairs for different identities", func() {
			// create first identity
			identity1 := builders.MeshIdentity().
				WithName("identity-1").
				WithSelector(&v1alpha1.LabelSelector{
					MatchLabels: &map[string]string{
						"app": "app-1",
					},
				}).WithBundledAutoGenerated().Build()
			Expect(resourceManager.Create(context.TODO(), identity1, core_store.CreateBy(model.MetaToResourceKey(identity1.Meta)))).To(Succeed())
			Expect(bundledProvider.Initialize(context.TODO(), identity1)).To(Succeed())

			// create second identity
			identity2 := builders.MeshIdentity().
				WithName("identity-2").
				WithSelector(&v1alpha1.LabelSelector{
					MatchLabels: &map[string]string{
						"app": "app-2",
					},
				}).WithBundledAutoGenerated().Build()
			Expect(resourceManager.Create(context.TODO(), identity2, core_store.CreateBy(model.MetaToResourceKey(identity2.Meta)))).To(Succeed())
			Expect(bundledProvider.Initialize(context.TODO(), identity2)).To(Succeed())

			// create proxy for first identity
			proxy1 := xds_builders.Proxy().
				WithDataplane(builders.Dataplane().
					WithName("web-01").
					WithAddress("192.168.0.2").
					WithLabels(map[string]string{
						metadata.KumaServiceAccount: "sa-1",
						mesh_proto.KubeNamespaceTag: "ns-1",
						"app":                       "app-1",
					}).
					WithInboundOfTags(mesh_proto.ServiceTag, "web", mesh_proto.ProtocolTag, "http")).
				Build()

			// create proxy for second identity
			proxy2 := xds_builders.Proxy().
				WithDataplane(builders.Dataplane().
					WithName("web-02").
					WithAddress("192.168.0.3").
					WithLabels(map[string]string{
						metadata.KumaServiceAccount: "sa-2",
						mesh_proto.KubeNamespaceTag: "ns-2",
						"app":                       "app-2",
					}).
					WithInboundOfTags(mesh_proto.ServiceTag, "api", mesh_proto.ProtocolTag, "http")).
				Build()

			// when - create identities
			workloadIdentity1, err := bundledProvider.CreateIdentity(context.TODO(), identity1, proxy1)
			Expect(err).ToNot(HaveOccurred())
			workloadIdentity2, err := bundledProvider.CreateIdentity(context.TODO(), identity2, proxy2)
			Expect(err).ToNot(HaveOccurred())

			// then - verify certificates have different issuers
			cert1, err := readCertificate(workloadIdentity1, kri.From(identity1).String())
			Expect(err).ToNot(HaveOccurred())
			cert2, err := readCertificate(workloadIdentity2, kri.From(identity2).String())
			Expect(err).ToNot(HaveOccurred())

			// Verify the certificates have different SPIFFEIDs
			Expect(cert1.URIs[0].String()).To(Equal("spiffe://default.my-zone.mesh.local/ns/ns-1/sa/sa-1"))
			Expect(cert2.URIs[0].String()).To(Equal("spiffe://default.my-zone.mesh.local/ns/ns-2/sa/sa-2"))

			// Verify each certificate is signed by its corresponding CA
			ca1 := core_system.NewSecretResource()
			Expect(secretManager.Get(context.TODO(), ca1, core_store.GetByKey(bundled.RootCAName(model.GetDisplayName(identity1.GetMeta())), identity1.Meta.GetMesh()))).To(Succeed())
			ca2 := core_system.NewSecretResource()
			Expect(secretManager.Get(context.TODO(), ca2, core_store.GetByKey(bundled.RootCAName(model.GetDisplayName(identity2.GetMeta())), identity2.Meta.GetMesh()))).To(Succeed())

			// Parse CA certificates
			caCert1Block, _ := pem.Decode(ca1.Spec.Data.GetValue())
			caCert1, err := x509.ParseCertificate(caCert1Block.Bytes)
			Expect(err).ToNot(HaveOccurred())
			caCert2Block, _ := pem.Decode(ca2.Spec.Data.GetValue())
			caCert2, err := x509.ParseCertificate(caCert2Block.Bytes)
			Expect(err).ToNot(HaveOccurred())

			// Verify cert1 is signed by ca1 and cert2 is signed by ca2
			Expect(cert1.CheckSignatureFrom(caCert1)).To(Succeed())
			Expect(cert2.CheckSignatureFrom(caCert2)).To(Succeed())

			// Verify cert1 is NOT signed by ca2 and cert2 is NOT signed by ca1
			Expect(cert1.CheckSignatureFrom(caCert2)).To(HaveOccurred())
			Expect(cert2.CheckSignatureFrom(caCert1)).To(HaveOccurred())
		})
	})
})

func readCertificate(identity *core_xds.WorkloadIdentity, kri string) (*x509.Certificate, error) {
	secrets := identity.AdditionalResources.Resources(envoy_resource.SecretType)
	secret := secrets[kri].Resource.(*envoy_auth.Secret)
	certificate := secret.GetTlsCertificate().CertificateChain.GetInlineBytes()
	// Decode PEM block
	block, _ := pem.Decode(certificate)
	if block == nil || block.Type != "CERTIFICATE" {
		panic("failed to decode PEM block containing certificate")
	}

	// Parse the certificate
	return x509.ParseCertificate(block.Bytes)
}
