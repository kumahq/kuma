package status

import (
	"context"
	"time"

	"github.com/go-logr/logr"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	kube_meta "k8s.io/apimachinery/pkg/apis/meta/v1"

	common_api "github.com/kumahq/kuma/api/common/v1alpha1"
	"github.com/kumahq/kuma/pkg/core/kri"
	meshidentity_api "github.com/kumahq/kuma/pkg/core/resources/apis/meshidentity/api/v1alpha1"
	"github.com/kumahq/kuma/pkg/core/resources/apis/meshidentity/providers"
	"github.com/kumahq/kuma/pkg/core/resources/apis/meshidentity/providers/bundled"
	meshtrust_api "github.com/kumahq/kuma/pkg/core/resources/apis/meshtrust/api/v1alpha1"
	"github.com/kumahq/kuma/pkg/core/resources/apis/system"
	"github.com/kumahq/kuma/pkg/core/resources/manager"
	"github.com/kumahq/kuma/pkg/core/resources/model"
	"github.com/kumahq/kuma/pkg/core/resources/store"
	core_metrics "github.com/kumahq/kuma/pkg/metrics"
	"github.com/kumahq/kuma/pkg/plugins/resources/memory"
	"github.com/kumahq/kuma/pkg/test/resources/builders"
	"github.com/kumahq/kuma/pkg/test/resources/samples"
	"github.com/kumahq/kuma/pkg/util/pointer"
)

var _ = Describe("Updater", func() {
	var stopCh chan struct{}
	var resManager manager.ResourceManager
	var metrics core_metrics.Metrics

	BeforeEach(func() {
		m, err := core_metrics.NewMetrics("")
		Expect(err).ToNot(HaveOccurred())
		metrics = m
		resManager = manager.NewResourceManager(memory.NewStore())

		bundledProvider, err := bundled.NewBundledIdentityProvider(resManager, resManager, metrics, "zone")
		Expect(err).ToNot(HaveOccurred())

		updater, err := New(logr.Discard(), 50*time.Millisecond, resManager, resManager, providers.IdentityProviders{
			"Bundled": bundledProvider,
		}, "east")
		Expect(err).ToNot(HaveOccurred())
		stopCh = make(chan struct{})
		go func(stopCh chan struct{}) {
			defer GinkgoRecover()
			Expect(updater.Start(stopCh)).To(Succeed())
		}(stopCh)

		Expect(samples.MeshDefaultBuilder().Create(resManager)).To(Succeed())
	})

	AfterEach(func() {
		close(stopCh)
	})

	It("should successfully reconcile mesh identity", func() {
		// when
		identity := builders.MeshIdentity().WithBundledAutoGenerated().Build()
		Expect(resManager.Create(context.Background(), identity, store.CreateBy(model.MetaToResourceKey(identity.GetMeta())))).To(Succeed())

		// then
		Eventually(func(g Gomega) {
			mid := meshidentity_api.NewMeshIdentityResource()
			err := resManager.Get(context.Background(), mid, store.GetBy(model.MetaToResourceKey(identity.GetMeta())))
			g.Expect(err).ToNot(HaveOccurred())
			g.Expect(mid.Status.Conditions).To(ContainElements(
				common_api.Condition{
					Type:    meshidentity_api.ProviderConditionType,
					Status:  kube_meta.ConditionTrue,
					Reason:  "ProviderInitialized",
					Message: "Provider successfully initialized",
				},
				common_api.Condition{
					Type:    meshidentity_api.MeshTrustConditionType,
					Status:  kube_meta.ConditionTrue,
					Reason:  "MeshTrustCreated",
					Message: "MeshTrust has been successfully created",
				},
				common_api.Condition{
					Type:    meshidentity_api.ReadyConditionType,
					Status:  kube_meta.ConditionTrue,
					Reason:  "Ready",
					Message: "Successfully initialized",
				},
			))
		}, "10s", "100ms").Should(Succeed())

		// ca and private key should be initialized
		// and
		privateKey := system.NewSecretResource()
		Expect(resManager.Get(context.Background(), privateKey, store.GetByKey(bundled.PrivateKeyName(identity.Meta.GetName()), "default"))).ToNot(HaveOccurred())
		Expect(privateKey.Spec.Data.GetValue()).ToNot(BeNil())

		ca := system.NewSecretResource()
		Expect(resManager.Get(context.Background(), ca, store.GetByKey(bundled.RootCAName(identity.Meta.GetName()), "default"))).ToNot(HaveOccurred())
		Expect(privateKey.Spec.Data.GetValue()).ToNot(BeNil())

		// meshtrust should be created
		meshTrust := meshtrust_api.NewMeshTrustResource()
		Expect(resManager.Get(context.Background(), meshTrust, store.GetByKey(identity.Meta.GetName(), "default"))).ToNot(HaveOccurred())
		Expect(meshTrust.Spec.Origin.KRI).To(Equal(pointer.To(kri.From(identity).String())))
		Expect(meshTrust.Spec.CABundles).To(HaveLen(1))
	})

	It("should fail to reconcile invalid name", func() {
		// when
		identity := builders.MeshIdentity().WithBundledAutoGenerated().Build()
		identity.Spec.SpiffeID = &meshidentity_api.SpiffeID{
			TrustDomain: pointer.To("{.incorrect}.name"),
		}
		Expect(resManager.Create(context.Background(), identity, store.CreateBy(model.MetaToResourceKey(identity.GetMeta())))).To(Succeed())

		// then
		Eventually(func(g Gomega) {
			mid := meshidentity_api.NewMeshIdentityResource()
			err := resManager.Get(context.Background(), mid, store.GetBy(model.MetaToResourceKey(identity.GetMeta())))
			g.Expect(err).ToNot(HaveOccurred())
			g.Expect(mid.Status.Conditions).To(ContainElements(
				common_api.Condition{
					Type:    meshidentity_api.ProviderConditionType,
					Status:  kube_meta.ConditionFalse,
					Reason:  "ProviderInitializationError",
					Message: "failed to generate X509 certificate: trust domain characters are limited to lowercase letters, numbers, dots, dashes, and underscores",
				},
				common_api.Condition{
					Type:    meshidentity_api.ReadyConditionType,
					Status:  kube_meta.ConditionFalse,
					Reason:  "Failure",
					Message: "One of initialization steps failed",
				},
			))
		}, "10s", "100ms").Should(Succeed())

		// backend shouldn't be initialized
		privateKey := system.NewSecretResource()
		Expect(resManager.Get(context.Background(), privateKey, store.GetByKey(bundled.PrivateKeyName(identity.Meta.GetName()), "default"))).To(HaveOccurred())
	})

	It("should not initialize provider if secrets already exists", func() {
		// when
		identity := builders.MeshIdentity().WithBundledAutoGenerated().Build()
		Expect(resManager.Create(context.Background(), identity, store.CreateBy(model.MetaToResourceKey(identity.GetMeta())))).To(Succeed())

		// then
		Eventually(func(g Gomega) {
			mid := meshidentity_api.NewMeshIdentityResource()
			err := resManager.Get(context.Background(), mid, store.GetBy(model.MetaToResourceKey(identity.GetMeta())))
			g.Expect(err).ToNot(HaveOccurred())
			g.Expect(mid.Status.Conditions).To(ContainElements(
				common_api.Condition{
					Type:    meshidentity_api.ProviderConditionType,
					Status:  kube_meta.ConditionTrue,
					Reason:  "ProviderInitialized",
					Message: "Provider successfully initialized",
				},
				common_api.Condition{
					Type:    meshidentity_api.MeshTrustConditionType,
					Status:  kube_meta.ConditionTrue,
					Reason:  "MeshTrustCreated",
					Message: "MeshTrust has been successfully created",
				},
				common_api.Condition{
					Type:    meshidentity_api.ReadyConditionType,
					Status:  kube_meta.ConditionTrue,
					Reason:  "Ready",
					Message: "Successfully initialized",
				},
			))
		}, "10s", "100ms").Should(Succeed())

		// ca and private key should be initialized
		// and
		existingPrivateKey := system.NewSecretResource()
		Expect(resManager.Get(context.Background(), existingPrivateKey, store.GetByKey(bundled.PrivateKeyName(identity.Meta.GetName()), "default"))).ToNot(HaveOccurred())
		Expect(existingPrivateKey.Spec.Data.GetValue()).ToNot(BeNil())

		existingCa := system.NewSecretResource()
		Expect(resManager.Get(context.Background(), existingCa, store.GetByKey(bundled.RootCAName(identity.Meta.GetName()), "default"))).ToNot(HaveOccurred())
		Expect(existingCa.Spec.Data.GetValue()).ToNot(BeNil())

		Consistently(func(g Gomega) {
			privateKey := system.NewSecretResource()
			Expect(resManager.Get(context.Background(), privateKey, store.GetByKey(bundled.PrivateKeyName(identity.Meta.GetName()), "default"))).ToNot(HaveOccurred())
			Expect(privateKey.Spec.Data.GetValue()).To(Equal(existingPrivateKey.Spec.Data.GetValue()))

			ca := system.NewSecretResource()
			Expect(resManager.Get(context.Background(), ca, store.GetByKey(bundled.RootCAName(identity.Meta.GetName()), "default"))).ToNot(HaveOccurred())
			Expect(ca.Spec.Data.GetValue()).To(Equal(existingCa.Spec.Data.GetValue()))
		}, "1s", "100ms").To(Succeed())
	})

	It("should append existing meshtrust if one already exists", func() {
		// when
		meshTrust := builders.MeshTrust().WithName("identity").Build()
		Expect(resManager.Create(context.Background(), meshTrust, store.CreateBy(model.MetaToResourceKey(meshTrust.GetMeta())))).To(Succeed())

		identity := builders.MeshIdentity().WithBundledAutoGenerated().WithName("identity").Build()
		Expect(resManager.Create(context.Background(), identity, store.CreateBy(model.MetaToResourceKey(identity.GetMeta())))).To(Succeed())

		// then
		Eventually(func(g Gomega) {
			mid := meshidentity_api.NewMeshIdentityResource()
			err := resManager.Get(context.Background(), mid, store.GetBy(model.MetaToResourceKey(identity.GetMeta())))
			g.Expect(err).ToNot(HaveOccurred())
			g.Expect(mid.Status.Conditions).To(ContainElements(
				common_api.Condition{
					Type:    meshidentity_api.ProviderConditionType,
					Status:  kube_meta.ConditionTrue,
					Reason:  "ProviderInitialized",
					Message: "Provider successfully initialized",
				},
				common_api.Condition{
					Type:    meshidentity_api.MeshTrustConditionType,
					Status:  kube_meta.ConditionTrue,
					Reason:  "MeshTrustCreated",
					Message: "MeshTrust has been successfully created",
				},
				common_api.Condition{
					Type:    meshidentity_api.ReadyConditionType,
					Status:  kube_meta.ConditionTrue,
					Reason:  "Ready",
					Message: "Successfully initialized",
				},
			))
		}, "10s", "100ms").Should(Succeed())

		// should append existing MeshTrust
		trust := meshtrust_api.NewMeshTrustResource()
		Expect(resManager.Get(context.Background(), trust, store.GetByKey("identity", "default"))).To(Succeed())
		Expect(trust.Spec.CABundles).To(HaveLen(2))
	})
})
