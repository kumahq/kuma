package status

import (
	"context"
	"time"

	"github.com/go-logr/logr"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	kube_meta "k8s.io/apimachinery/pkg/apis/meta/v1"

	common_api "github.com/kumahq/kuma/api/common/v1alpha1"
	meshidentity_api "github.com/kumahq/kuma/pkg/core/resources/apis/meshidentity/api/v1alpha1"
	"github.com/kumahq/kuma/pkg/core/resources/apis/meshidentity/providers"
	"github.com/kumahq/kuma/pkg/core/resources/apis/meshidentity/providers/bundled"
	"github.com/kumahq/kuma/pkg/core/resources/apis/system"
	"github.com/kumahq/kuma/pkg/core/resources/manager"
	"github.com/kumahq/kuma/pkg/core/resources/model"
	"github.com/kumahq/kuma/pkg/core/resources/store"
	core_metrics "github.com/kumahq/kuma/pkg/metrics"
	"github.com/kumahq/kuma/pkg/plugins/resources/memory"
	"github.com/kumahq/kuma/pkg/test/resources/builders"
	"github.com/kumahq/kuma/pkg/test/resources/samples"
	"github.com/kumahq/kuma/pkg/util/pointer"
)

var _ = Describe("Updater", func() {
	var stopCh chan struct{}
	var resManager manager.ResourceManager
	var metrics core_metrics.Metrics

	BeforeEach(func() {
		m, err := core_metrics.NewMetrics("")
		Expect(err).ToNot(HaveOccurred())
		metrics = m
		resManager = manager.NewResourceManager(memory.NewStore())

		bundledProvider, err := bundled.NewBundledIdentityProvider(resManager, resManager, metrics, "zone")
		Expect(err).ToNot(HaveOccurred())

		updater, err := New(logr.Discard(), 50*time.Millisecond, resManager, resManager, providers.IdentityProviders{
			"Bundled": bundledProvider,
		}, "east")
		Expect(err).ToNot(HaveOccurred())
		stopCh = make(chan struct{})
		go func(stopCh chan struct{}) {
			defer GinkgoRecover()
			Expect(updater.Start(stopCh)).To(Succeed())
		}(stopCh)

		Expect(samples.MeshDefaultBuilder().Create(resManager)).To(Succeed())
	})

	AfterEach(func() {
		close(stopCh)
	})

	It("should successfully reconcile mesh identity", func() {
		// when
		identity := builders.MeshIdentity().WithBundledAutoGenerated().Build()
		Expect(resManager.Create(context.Background(), identity, store.CreateBy(model.MetaToResourceKey(identity.GetMeta())))).To(Succeed())

		// then
		Eventually(func(g Gomega) {
			mid := meshidentity_api.NewMeshIdentityResource()
			err := resManager.Get(context.Background(), mid, store.GetBy(model.MetaToResourceKey(identity.GetMeta())))
			g.Expect(err).ToNot(HaveOccurred())
			g.Expect(mid.Status.Conditions).To(ContainElements(
				common_api.Condition{
					Type:    meshidentity_api.ProviderConditionType,
					Status:  kube_meta.ConditionTrue,
					Reason:  "ProviderInitialized",
					Message: "Provider successfully initialized",
				},
				common_api.Condition{
					Type:    meshidentity_api.ReadyConditionType,
					Status:  kube_meta.ConditionTrue,
					Reason:  "Ready",
					Message: "Successfully initialized",
				},
			))
		}, "10s", "100ms").Should(Succeed())

		// ca and private key should be initialized
		// and
		privateKey := system.NewSecretResource()
		Expect(resManager.Get(context.Background(), privateKey, store.GetByKey(bundled.PrivateKeyName(identity.Meta.GetName()), "default"))).ToNot(HaveOccurred())
		Expect(privateKey.Spec.Data.GetValue()).ToNot(BeNil())

		ca := system.NewSecretResource()
		Expect(resManager.Get(context.Background(), ca, store.GetByKey(bundled.RootCAName(identity.Meta.GetName()), "default"))).ToNot(HaveOccurred())
		Expect(privateKey.Spec.Data.GetValue()).ToNot(BeNil())
	})

	It("should fail to reconcile invalid name", func() {
		// when
		identity := builders.MeshIdentity().WithBundledAutoGenerated().Build()
		identity.Spec.SpiffeID = &meshidentity_api.SpiffeID{
			TrustDomain: pointer.To("{.incorrect}.name"),
		}
		Expect(resManager.Create(context.Background(), identity, store.CreateBy(model.MetaToResourceKey(identity.GetMeta())))).To(Succeed())

		// then
		Eventually(func(g Gomega) {
			mid := meshidentity_api.NewMeshIdentityResource()
			err := resManager.Get(context.Background(), mid, store.GetBy(model.MetaToResourceKey(identity.GetMeta())))
			g.Expect(err).ToNot(HaveOccurred())
			g.Expect(mid.Status.Conditions).To(ContainElements(
				common_api.Condition{
					Type:    meshidentity_api.ProviderConditionType,
					Status:  kube_meta.ConditionFalse,
					Reason:  "ProviderInitializationError",
					Message: "failed to generate X509 certificate: trust domain characters are limited to lowercase letters, numbers, dots, dashes, and underscores",
				},
				common_api.Condition{
					Type:    meshidentity_api.ReadyConditionType,
					Status:  kube_meta.ConditionFalse,
					Reason:  "Failure",
					Message: "One of initialization steps failed",
				},
			))
		}, "10s", "100ms").Should(Succeed())

		// backend shouldn't be initialized
		privateKey := system.NewSecretResource()
		Expect(resManager.Get(context.Background(), privateKey, store.GetByKey(bundled.PrivateKeyName(identity.Meta.GetName()), "default"))).To(HaveOccurred())
	})

	It("should not initialize provider if it was already initialized", func() {
		// when
		identity := builders.MeshIdentity().WithBundledAutoGenerated().Build()
		identity.Status = &meshidentity_api.MeshIdentityStatus{
			Conditions: []common_api.Condition{
				{
					Type:    meshidentity_api.ProviderConditionType,
					Status:  kube_meta.ConditionTrue,
					Reason:  "ProviderInitialized",
					Message: "Provider successfully initialized",
				},
				{
					Type:    meshidentity_api.ReadyConditionType,
					Status:  kube_meta.ConditionTrue,
					Reason:  "Ready",
					Message: "Successfully initialized",
				},
			},
		}
		Expect(resManager.Create(context.Background(), identity, store.CreateBy(model.MetaToResourceKey(identity.GetMeta())))).To(Succeed())

		// then
		Eventually(func(g Gomega) {
			mid := meshidentity_api.NewMeshIdentityResource()
			err := resManager.Get(context.Background(), mid, store.GetBy(model.MetaToResourceKey(identity.GetMeta())))
			g.Expect(err).ToNot(HaveOccurred())
			g.Expect(mid.Status.Conditions).To(ContainElements(
				common_api.Condition{
					Type:    meshidentity_api.ProviderConditionType,
					Status:  kube_meta.ConditionTrue,
					Reason:  "ProviderInitialized",
					Message: "Provider successfully initialized",
				},
				common_api.Condition{
					Type:    meshidentity_api.ReadyConditionType,
					Status:  kube_meta.ConditionTrue,
					Reason:  "Ready",
					Message: "Successfully initialized",
				},
			))
		}, "10s", "100ms").Should(Succeed())

		// should not create secret since status was already set as reconciled
		privateKey := system.NewSecretResource()
		Expect(resManager.Get(context.Background(), privateKey, store.GetByKey(bundled.PrivateKeyName(identity.Meta.GetName()), "default"))).To(HaveOccurred())
	})
})
