---
applyTo:
  - "pkg/plugins/policies/**"
---

# Policy Development Guidelines

## Policy Structure

### Standard Structure

```
pkg/plugins/policies/<policy-name>/
  api/v1alpha1/
    <policy>.go                      # Type definitions with +kuma:policy: markers
    validator.go                     # Validation logic
    validator_test.go                # Validation tests
    deprecated.go                    # Deprecation warnings (optional)
    helpers.go                       # Policy-specific helpers (optional)
    suite_test.go                    # Ginkgo test suite
    zz_generated.deepcopy.go         # GENERATED - DO NOT EDIT
    zz_generated.resource.go         # GENERATED - DO NOT EDIT
    zz_generated.helpers.go          # GENERATED - DO NOT EDIT
  k8s/
    crd/
      kuma.io_<policy>s.yaml         # GENERATED K8s CRD
    v1alpha1/
      groupversion_info.go           # K8s API registration
      zz_generated.types.go          # GENERATED - DO NOT EDIT
      zz_generated.deepcopy.go       # GENERATED - DO NOT EDIT
  plugin/v1alpha1/
    plugin.go                        # Main plugin implementation
    plugin_test.go                   # Plugin tests
    plugin_suite_test.go             # Ginkgo suite
    testdata/*.golden.yaml           # Golden files
  xds/                               # OR plugin/xds/ (both valid)
    configurer.go                    # Envoy configurers
  zz_generated.plugin.go             # GENERATED - DO NOT EDIT
```

### Special Directories (Complex Policies)
- `graph/` - Graph algorithms (meshtrafficpermission)
- `metadata/` - Metadata helpers (meshaccesslog, meshmetric, meshpassthrough, meshproxypatch, meshtrace, meshtrafficpermission)
- `dpapi/` - Data plane API (meshmetric)
- `filters/` - HTTP filter builders (meshhttproute)

## Development Checklist

### API (`api/v1alpha1/`)

**Types (<policy>.go):**
- Define policy structs with proper field tags
- Add `+kuma:policy:` markers if needed:
  - `+kuma:policy:is_from_as_rules=true`
  - `+kuma:policy:skip_get_default=true`
  - `+kuma:policy:singular_display_name=<name>`
- Run `make generate` after changes

**Validation (validator.go):**
- Implement `(r *<Policy>Resource) validate() error`
- Use `validators.ValidationError` and path builders
- Validate targetRef with `mesh.ValidateTargetRef()`
- Support policy roles (System vs User) with different TargetRef rules
- Helper functions: `validateFrom()`, `validateTo()`, `validateRules()`, `validateDefault()`
- All TargetRef kinds: `Mesh`, `MeshService`, `MeshSubset`, `MeshServiceSubset`
- Inbound (`from`) and outbound (`to`) rules if applicable

**Testing (validator_test.go):**
- Table-driven tests with `DescribeTable()`
- Test all validation edge cases
- Ginkgo/Gomega assertions

**Other Files:**
- `deprecated.go` - Implement `Deprecations() []string` if deprecating fields
- `helpers.go` - Policy-specific helper methods (route policies)
- `suite_test.go` - Standard Ginkgo setup

### K8s (`k8s/v1alpha1/`)
- `groupversion_info.go` - Standard boilerplate for kuma.io group
- CRD YAML generated by `make generate`

### Plugin (`plugin/v1alpha1/`)

**Interface Implementation:**
- Implement `core_plugins.PolicyPlugin` interface
- `MatchedPolicies()` - Use `matchers.MatchedPolicies(api.<Policy>Type, ...)`
- `Apply()` - Main xDS application logic

**Apply Pattern:**
1. Extract policies: `proxy.Policies.Dynamic[api.<Policy>Type]`
2. Gather resources: `xds.GatherListeners(rs)`, `xds.GatherClusters(rs)`
3. Apply helpers:
   - `applyToInbounds()` - Inbound traffic
   - `applyToOutbounds()` - Outbound traffic
   - `applyToGateway()` - Gateway listeners
   - `applyToRealResource()` - Resource-based routing (newer)

**Testing:**
- Golden file tests in `testdata/*.golden.yaml`
- Test cluster, listener, route configurations
- Naming: `<scenario>.<type>.golden.yaml` (e.g., `basic.listener.golden.yaml`)
- Gateway tests: `<scenario>.gateway.<type>.golden.yaml`
- Update: `UPDATE_GOLDEN_FILES=true make test`
- Use `matchers.MatchGoldenYAML()` in tests

### XDS (`xds/` or `plugin/xds/`)

**Configurer Types:**
- `ClusterConfigurer` - Modifies Envoy clusters
- `ListenerConfigurer` - Modifies Envoy listeners
- `DeprecatedListenerConfigurer` - Legacy kuma.io/service support
- Strategy pattern: `func (c *Configurer) Configure(resource) error`

**Protocol Handling:**
```go
switch protocol {
case core_meta.ProtocolHTTP, core_meta.ProtocolHTTP2, core_meta.ProtocolGRPC:
    // HTTP-specific: listeners_v3.UpdateHTTPConnectionManager()
case core_meta.ProtocolUnknown, core_meta.ProtocolTCP, core_meta.ProtocolKafka:
    // TCP-specific: listeners_v3.UpdateTCPProxy()
}
```

**Best Practices:**
- Efficient ResourceSet usage
- Add metadata for debugging
- Use envoy helpers: `listeners_v3.*`, `clusters_v3.*`
- Protocol-specific configuration paths

## Before Implementation

1. **Search similar policies:** `pkg/plugins/policies/<similar-name>/`
2. **Study patterns:**
   - Validator structure (validateFrom/To/Rules)
   - Plugin Apply helpers (applyToInbounds/Outbounds/Gateway)
   - Configurer types (Cluster/Listener)
3. **Check complexity:** Simple (timeout, retry) vs Complex (httproute, trafficpermission)
4. **Verify compatibility:** K8s + Universal scenarios
5. **Plan testing:** Inbound + outbound + gateway scenarios

## Code Generation

**After changes to:**
- `api/v1alpha1/<policy>.go` (type definitions)
- `+kuma:policy:` markers
- Proto files

**Run:** `make generate`

**Generated files (DO NOT EDIT):**
- `zz_generated.*.go` (all directories)
- `k8s/crd/*.yaml`

## Review Focus

### API
- Complete validator with edge cases
- Policy role support (System vs User)
- All TargetRef kinds supported
- From/to rules correctly validated
- Deprecation warnings if needed

### Structure
- Correct directory layout (api/k8s/plugin/xds)
- Generated files not modified
- Test files present (validator_test.go, plugin_test.go, suite_test.go)
- Golden files in plugin/v1alpha1/testdata/

### Plugin
- MatchedPolicies uses matchers.MatchedPolicies()
- Apply helpers follow pattern (applyToInbounds/Outbounds/Gateway)
- Protocol-specific handling
- Resource-based routing for newer policies

### XDS
- Configurer types appropriate (Cluster/Listener)
- Protocol switching correct
- Envoy helpers used (listeners_v3, clusters_v3)
- Deprecated configurer if legacy support needed

### Testing
- Validator table-driven tests
- Plugin golden file tests
- K8s + Universal scenarios
- Inbound + outbound + gateway cases
- Golden files update cleanly

## Common Patterns

### Validator Pattern
```go
func (r *<Policy>Resource) validate() error {
    var verr validators.ValidationError
    path := validators.RootedAt("spec")

    verr.AddErrorAt(path.Field("targetRef"), r.validateTop(...))
    verr.AddErrorAt(path, validateFrom(...))
    verr.AddErrorAt(path, validateTo(...))

    return verr.OrNil()
}
```

### Plugin Pattern
```go
var _ core_plugins.PolicyPlugin = &plugin{}

func (p plugin) MatchedPolicies(dataplane, resources, opts) (TypedMatchingPolicies, error) {
    return matchers.MatchedPolicies(api.<Policy>Type, dataplane, resources, opts...)
}

func (p plugin) Apply(rs *ResourceSet, ctx Context, proxy *Proxy) error {
    policies := proxy.Policies.Dynamic[api.<Policy>Type]
    // Apply to inbounds, outbounds, gateway
}
```

### Configurer Pattern
```go
type ClusterConfigurer struct {
    Timeout *Duration
    Protocol Protocol
}

func (c *ClusterConfigurer) Configure(cluster *envoy_cluster.Cluster) error {
    // Modify cluster configuration
    return nil
}
```
