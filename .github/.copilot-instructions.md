# Kuma Service Mesh

## Overview

CNCF service mesh (Envoy-based) for K8s/VMs. L4-L7 connectivity, security, observability, multi-zone/multi-mesh.

**Tech Stack:** Go 1.23+, Envoy, Kubernetes/VMs, Ginkgo/Gomega, protobuf, mise

**Purpose:** Universal service mesh supporting both Kubernetes and VMs with automatic mTLS, traffic control, observability, and multi-zone deployments. Built by Kong, donated to CNCF.

---

## Project Structure

```
/app/                    # Main apps (kuma-cp, kuma-dp, kumactl, cni, kuma-ui)
/pkg/
  core/                  # Resources, managers, validators, plugins
  xds/                   # Envoy xDS (cache, envoy/, server)
  kds/                   # Multi-zone sync (Kuma Discovery Service)
  plugins/policies/      # 20+ policies (api/, plugin/, xds/)
  config/api-server/dp-server/  # Config, APIs, servers
  test/                  # Test utilities, matchers, builders
/test/                   # E2E and integration tests
/docs/madr/              # Architecture Decision Records
```

**Key Modules:**
- **Control Plane** (`pkg/core/`, `app/kuma-cp/`) - xDS, mTLS, multi-zone
- **Policies** (`pkg/plugins/policies/<name>/`) - api/v1alpha1/, plugin/, xds/
- **XDS** (`pkg/xds/`) - Envoy config generation, dual-tier cache

**Code Generation:** Run `make generate` after changes to `.proto`, `pkg/plugins/policies/*/api/`, resource definitions. Generated: `zz_generated.*`, `*.pb.go`

---

## Development Workflow

**Before Coding:**
1. ASK questions until 95% confident
2. Search for similar implementations (Grep/Glob)
3. Read existing code in relevant `pkg/` directory
4. Create plan, get approval (use Plan Mode for complex tasks)
5. Work incrementally (20-50 lines per step)

**Process:**
1. `make check` - clean state (ONLY for code changes, skip for config/docs/CI)
2. Read existing code
3. Write tests first (`*_test.go`, Ginkgo/Gomega)
4. Implement minimal changes
5. `make check && make test` - validate

---

## Go Conventions

### Error Handling

```go
// Custom error types with Is() - NO reflect.TypeOf
func (e *NotFound) Is(err error) bool {
    _, ok := err.(*NotFound)  // Use type assertion
    return ok
}

// Wrap with context
return errors.Errorf("failed to create dataplane: %w", err)

// Type assertions with clear messages
if !ok {
    return errors.Errorf("invalid type: expected=%T, got=%T", expectedType, actualType)
}

// Multi-error (transactions)
import "go.uber.org/multierr"
return multierr.Append(errors.Wrap(rollbackErr, "rollback failed"), err)
```

**Rules:** Always wrap errors ‚Ä¢ Use custom types with `Is()` ‚Ä¢ NO `reflect.TypeOf()` ‚Ä¢ Check `context.Canceled` before rollback ‚Ä¢ Use `multierr` for multiple errors

### Naming & Organization

**Naming:** Unexported types (`dataplaneManager`) ‚Ä¢ Exported interfaces (`ResourceManager`) ‚Ä¢ Descriptive constants

**Patterns:**
- Embedded interfaces for composition: `struct { ResourceManager; store Store }`
- Strategy pattern: `type TimeoutConfigurer struct {...}; func (t) Configure(cluster) error`
- Context propagation: `type ctxKey struct{}`; `context.WithValue(ctx, ctxKey{}, val)`
- Builder for tests: `Dataplane().WithName("x").Build()`

**Comments:** Public APIs only ‚Ä¢ Explain "why" not "what" ‚Ä¢ Test markers: `// setup`, `// given`, `// when`, `// then`

### Linter Errors

**Formatter:** `gofmt` (auto via `make check`)
**Linter:** `golangci-lint` (config: `.golangci.yml`)

**ALWAYS:**
- Attempt to fix linter errors properly
- Research solutions online if unclear how to fix
- Fix root cause, not symptoms

**NEVER:**
- Use skip/disable directives (`//nolint`, `// revive:disable`)
- Ignore linter warnings
- Work around linter errors

**If stuck:**
1. Try fixing the error
2. Research online for proper solution
3. If still unclear after research, ASK what to do (don't skip/disable)

---

## Simplicity Principles

### Anti-Patterns to AVOID

‚ùå **NEVER:**
- Long functions (>50 lines per function)
- Over-engineering (unnecessary abstractions/configurers)
- `reflect.TypeOf()` for type checking
- Generic `interface{}` instead of typed maps
- Panics in production code
- Entire files at once
- Placeholders `// ... rest of code ...`

‚úÖ **ALWAYS:**
- Functions <50 lines, single responsibility
- Search existing patterns FIRST (Grep/Glob)
- Three similar lines > premature abstraction
- Minimal, surgical changes
- Reuse existing components

**Check before implementing:**
1. Does similar code exist? What pattern does it use?
2. Can this be simpler/shorter?
3. Am I following existing plugin/configurer/manager pattern?
4. Is this minimal change to achieve goal?

---

## Code Generation Rules

### NEVER

- Generate long functions (>50 lines per function)
- Generate entire files at once (>100 lines in single response)
- Make big changes in single step
- Use placeholders like `// ... rest of code ...`
- Modify code unrelated to the task
- Assume requirements without asking
- Add features beyond what's requested

### ALWAYS

- Show complete code (no placeholders)
- Incremental changes (20-50 lines per step)
- Surgical, minimal changes only
- Test-driven development (write tests first)
- Follow existing patterns found in codebase
- Ask questions before assuming requirements

### Incremental Development Process

**Break changes into steps:**
1. Define interfaces/types
2. Write tests (input/output pairs)
3. Implement core logic (minimal)
4. Add error handling
5. Run tests, iterate
6. Update golden files if needed

**Each step:** Review, test, approve, then proceed to next.

---

## Testing

### Testing with Ginkgo/Gomega

**Structure:**
```go
var _ = Describe("Feature", func() {
    It("should behave correctly", func() {
        // setup
        manager := NewManager(...)

        // given
        input := Resource{...}

        // when
        err := manager.Create(ctx, &input, key)
        Expect(err).ToNot(HaveOccurred())

        // then
        Expect(actual.Field).To(Equal("expected"))
    })
})
```

**Table-driven:**
```go
DescribeTable("should validate",
    func(yaml string) {
        err := FromYAML([]byte(yaml), &spec)
        Expect(err).ToNot(HaveOccurred())
    },
    Entry("full", `targetRef: ...`),
    Entry("minimal", `targetRef: {kind: Mesh}`),
)
```

**Golden Files:**
```go
Expect(yaml).To(matchers.MatchGoldenYAML("testdata", "file.yaml"))
// Update: UPDATE_GOLDEN_FILES=true make test
```

**Builders:**
```go
dp := test_builders.Dataplane().WithName("dp1").Build()  // Validates, panics on error
```

**Common Mistakes:** ‚ùå Missing flow comments ‚Ä¢ Not updating golden files ‚Ä¢ No validation in builders ‚Ä¢ Using `err == nil` instead of Gomega matchers

---

## Commands & Git

### Development

```bash
make install              # mise install
make build                # Build all
make check                # Lint/format (auto-fix)
make generate             # Gen code (proto, policies, resources)
make test                 # Run tests
make test/e2e             # E2E (slow)

make build/kuma-cp        # Build control plane
make test TEST_PKG_LIST=./pkg/xds/...    # Test specific package
UPDATE_GOLDEN_FILES=true make test       # Update golden files

make k3d/restart && skaffold dev          # Dev environment
```

### Git & PRs

```bash
git push --no-verify upstream branch    # ALWAYS use --no-verify
```

**Branches:** `master` (base), `release-{2.7,2.10,2.11,2.12}`
**Versions:** 2.7.19 (LTS), 2.10.8, 2.11.7, 2.12.3

**Commit Format:** [Conventional Commits](https://www.conventionalcommits.org/)
```
<type>(<scope>): <subject>

<body>

Fixes #123
```

**Types:** `feat`, `fix`, `chore`, `docs`, `test`, `refactor`, `ci`
**Scopes:** `kuma-cp`, `kuma-dp`, `kumactl`, `xds`, `kds`, `MeshRetry`, `api-server`
**Sign:** Use `-s -S` flags

**PR:** Base: `master` ‚Ä¢ Template: `.github/PULL_REQUEST_TEMPLATE.md` ‚Ä¢ Changelog: from title or `> Changelog:` ‚Ä¢ Labels: `ci/*` at creation ‚Ä¢ MADR: `docs/madr/decisions/000-template.md` ‚Ä¢ No Kong Mesh mentions (use "downstream project")

---

## Architecture & Domain

### Components

- **kuma-cp** - Control plane (xDS, mTLS, multi-zone coordinator)
- **kuma-dp** - Data plane (Envoy wrapper)
- **kumactl** - CLI
- **kuma-cni** - CNI plugin

**Multi-zone:** Global CP ‚Üí Zone CPs via KDS ‚Ä¢ Zone Ingress/Egress for cross-zone ‚Ä¢ K8s + Universal (VMs)

### Core Concepts

| Term | Definition | Usage |
|------|------------|-------|
| **Dataplane** | Envoy proxy instance per workload | Sidecar for each pod/VM |
| **Mesh** | Isolated namespace for resources | `default` mesh, can have multiple |
| **ZoneTag** | `kuma.io/zone` auto-added by CP | Marks dataplane origin zone |
| **TargetRef** | Policy selector | `Mesh`, `MeshService`, `MeshSubset` |
| **FromRules** | Inbound policies | TrafficPermission from services |
| **ToRules** | Outbound policies | RetryPolicy to dependencies |
| **MeshContext** | Cached config for xDS | Dual-tier cache (short TTL + hash) |
| **xDS** | Envoy discovery protocol | CDS/EDS/LDS/RDS |
| **KDS** | Kuma Discovery Service | Multi-zone sync |
| **Configurer** | Strategy for Envoy config | `TimeoutConfigurer`, `CircuitBreakerConfigurer` |
| **MatchedPolicies** | Policies for a dataplane | Based on TargetRef selectors |

### Policy Structure

```
pkg/plugins/policies/<policy-name>/
  api/v1alpha1/           # <policy>_types.go, validator.go
  plugin/v1alpha1/        # plugin.go (application logic)
  xds/                    # configurer.go (Envoy config)
```

**Example:**
```yaml
apiVersion: kuma.io/v1alpha1
kind: MeshTimeout
spec:
  targetRef: {kind: MeshService, name: backend}
  to:
    - targetRef: {kind: MeshService, name: db}
      default: {connectionTimeout: 5s, idleTimeout: 60s}
```

### xDS Protocol

**CDS** (Clusters) - Backend services
**EDS** (Endpoints) - Service endpoints
**LDS** (Listeners) - Inbound/outbound listeners
**RDS** (Routes) - HTTP routes

---

## Complexity Hotspots

| Area | Location | Challenge |
|------|----------|-----------|
| **Policy Matching** | `pkg/plugins/policies/core/matchers/` | Selector evaluation, wildcards, cross-zone |
| **XDS Generation** | `pkg/xds/generator/`, `pkg/xds/envoy/` | Merging policies, precedence, protocol-specific |
| **Multi-zone Sync** | `pkg/kds/` | Eventual consistency, failures, versioning |
| **Rule Resolution** | `pkg/plugins/policies/core/rules/` | Inbound/outbound, subsets, precedence |

**Tips:**
- Study existing matchers/configurers before adding new logic
- Use strategy pattern, keep configurers focused (single concern)
- Test K8s + Universal modes
- Validate mesh isolation and policy boundaries

---

## Gotchas & Debugging

### Common Issues

**Build:** `make install` (dependencies) ‚Ä¢ `make generate` (outdated code) ‚Ä¢ `make check` (formatting)
**Test:** `UPDATE_GOLDEN_FILES=true make test` (golden mismatch) ‚Ä¢ `make test/e2e` (cluster setup)
**Multi-zone:** Test K8s + Universal ‚Ä¢ Verify isolation ‚Ä¢ Validate cross-zone carefully

### Debugging

**Temp logs:** Prefix "DEBUG" for easy removal

**Envoy config:**
```bash
kubectl exec deploy/<name> -c kuma-sidecar -- \
  wget -qO- localhost:9901/config_dump | jq '.configs[]'
```

### Performance & Security

**Performance:** Minimize allocations (many dataplanes) ‚Ä¢ Optimize DB queries ‚Ä¢ XDS efficiency critical
**Security:** Validate external inputs ‚Ä¢ Careful with mTLS/certs ‚Ä¢ Follow RBAC implications ‚Ä¢ Secure secrets handling

### Tool Management

**mise:** Config: `mise.toml` ‚Ä¢ Pinned versions ‚Ä¢ `make install` or `mise install`
**Tools:** buf, ginkgo, helm, kind, kubectl, protoc, yq, golangci-lint, skaffold

---

## Resources

- **DEVELOPER.md** - Setup, testing details
- **CONTRIBUTING.md** - PR workflow, commit format
- **docs/madr/decisions/** - Architecture decisions
- **Kuma Docs** - https://kuma.io/docs
- **Slack** - https://kuma-mesh.slack.com

---

## PR Review Guidelines

### Review Methodology: Chain of Verification (CoVe) & Self-Critique

**IMPORTANT: Use this 3-step verification process for EVERY review comment:**

#### Step 1: Initial Analysis & Verification Questions

Before flagging any issue, generate verification questions:
```
1. "Is this actually a bug or just a different valid approach?"
2. "Did I check the surrounding context and imports?"
3. "Could this be intentional for a reason I'm missing?"
4. "Is this pattern used elsewhere in the codebase successfully?"
5. "Would this actually cause a runtime issue or just style preference?"
```

#### Step 2: Answer Your Own Questions

For each potential issue:
```markdown
**Initial Concern:** [What you think is wrong]

**Verification Check:**
- Q: Is this pattern used elsewhere successfully?
- A: [Check codebase for similar patterns]
- Q: Could this be intentional?
- A: [Consider the specific context]
- Q: Will this actually fail at runtime?
- A: [Trace through execution path]

**Confidence After Verification:** [%]
```

#### Step 3: Self-Critique Before Posting

Before posting any review comment, self-critique:

**Self-Critique Checklist:**
```
‚ñ° Did I verify this isn't a false positive?
‚ñ° Did I check if CI/linters would catch this?
‚ñ° Is my confidence genuinely >80%?
‚ñ° Did I provide a concrete fix, not just criticism?
‚ñ° Did I check existing code for precedent?
‚ñ° Am I being pedantic about style vs substance?
```

**Only post comment if:**
- Confidence remains >80% after verification
- It's not already handled by CI/linters
- You can provide specific fix with example
- It's substance, not style preference

### Example of CoVe in Practice

```markdown
## Initial Analysis
Found: Missing error check on line 42

## Verification Process
Q1: Is error checking enforced here?
A1: Yes, golangci-lint errcheck is enabled

Q2: Could this error realistically occur?
A2: Checking... this is internal API with validated input

Q3: What do similar functions do?
A3: Found 3 similar functions that DO check this error

## Self-Critique
- ‚úì Not a false positive
- ‚úì Real runtime risk
- ‚úì Can provide fix
- ‚úì Confidence: 95%

## Final Review Comment
**File:** pkg/xds/cache.go:42
**Issue:** Missing error check could cause silent failure
**Fix:**
```go
- cache.Set(key, value)
+ if err := cache.Set(key, value); err != nil {
+     return errors.Wrap(err, "failed to cache XDS config")
+ }
```
```

### Kuma-Specific Verification Questions

**For Policy Changes:**
```
Q: Does this follow the api/plugin/xds structure?
Q: Are there similar policies I can reference?
Q: Does this handle both K8s and Universal modes?
Q: Is TargetRef validation complete?
Q: Are both inbound and outbound rules covered?
```

**For XDS Changes:**
```
Q: Did I verify the generated Envoy config is valid?
Q: Is there a golden file test for this?
Q: Does this handle all protocol types (HTTP/TCP/GRPC)?
Q: Could this cause allocation pressure?
Q: Is caching/invalidation correct?
```

**For Multi-zone (KDS):**
```
Q: Does this maintain eventual consistency?
Q: Are cross-zone security boundaries preserved?
Q: Is version compatibility maintained?
Q: What happens on sync failure?
Q: Is resource isolation tested?
```

**For Error Handling:**
```
Q: Is the error wrapped with context?
Q: Is reflect.TypeOf used? (NEVER allowed)
Q: Are rollback errors properly handled?
Q: Does this use custom error types with Is()?
Q: Is multierr used for multiple errors?
```

### Common False Positives to Avoid

**DON'T Flag These:**

1. **Intentional Patterns:**
   ```go
   // ‚ùå DON'T flag: "Missing error check"
   _ = someCleanupFunction() // Intentional in defer cleanup
   ```

2. **Code Generation:**
   ```go
   // ‚ùå DON'T flag: "Function too long"
   // Files: zz_generated.*, *.pb.go
   ```

3. **Test Builders:**
   ```go
   // ‚ùå DON'T flag: "Panics in production"
   func Build() { panic() } // Test builders intentionally panic
   ```

4. **Existing CI Coverage:**
   ```
   ‚ùå DON'T flag: Import ordering (gci handles)
   ‚ùå DON'T flag: Formatting (gofmt handles)
   ‚ùå DON'T flag: Basic lints (golangci-lint handles)
   ```

5. **Valid Architectural Choices:**
   ```go
   // ‚ùå DON'T flag: "Could use interface"
   // Kuma often uses concrete types for performance
   ```

### Confidence Calibration

**Lower your confidence if:**
- You haven't checked similar code in the codebase
- The pattern might be intentional for performance
- It's in generated code or test utilities
- CI/linters would catch it
- It's about code organization, not correctness

**Increase your confidence if:**
- It violates explicit project rules (reflect.TypeOf, >50 lines)
- It's a security issue (secrets, auth, validation)
- It would cause runtime failures
- Multiple similar functions do it differently
- It breaks multi-zone isolation

### Review Priorities

**Severity Levels:**
- **üî¥ Block (95%+ confidence):** Security vulns, breaking changes, data loss, incorrect xDS generation
- **üü° Change (80%+ confidence):** Missing tests, unclear logic, performance issues, policy violations
- **üü¢ Comment (70%+ confidence):** Style, optimizations, minor improvements

### Core Review Checklist

#### 1. Security & Correctness

**Critical Security Points:**
```
- [ ] mTLS/cert handling secure (pkg/tls/, pkg/core/ca/)
- [ ] Multi-zone auth validated (pkg/intercp/)
- [ ] RBAC permissions checked (pkg/core/resources/access/)
- [ ] No secrets in logs/errors
- [ ] Input validation on all public APIs
- [ ] Cross-zone traffic properly isolated
```

**Correctness:**
```
- [ ] xDS generation produces valid Envoy config
- [ ] Policy matching handles all edge cases
- [ ] KDS sync maintains consistency
- [ ] Resource versions properly incremented
- [ ] Context propagation correct
- [ ] Rollback on multi-error scenarios
```

#### 2. Go Standards

**Error Handling MUST:**
```go
// ‚úÖ GOOD: Wrapped with context
return errors.Wrap(err, "failed to create dataplane")

// ‚ùå BAD: Raw error
return err

// ‚úÖ GOOD: Custom error with Is()
func (e *NotFound) Is(err error) bool {
    _, ok := err.(*NotFound)
    return ok
}

// ‚ùå BAD: Using reflect.TypeOf
func (e *NotFound) Is(err error) bool {
    return reflect.TypeOf(err) == reflect.TypeOf(e)
}

// ‚úÖ GOOD: Multi-error handling
return multierr.Append(rollbackErr, originalErr)

// ‚ùå BAD: Ignoring rollback error
_ = rollback()
return originalErr
```

**Function Size:**
```
- [ ] All functions <50 lines
- [ ] Single responsibility per function
- [ ] Complex logic extracted to helpers
```

#### 3. Service Mesh Specific

**Policy Implementation:**
```
pkg/plugins/policies/<policy>/
- [ ] api/v1alpha1/<policy>_types.go exists
- [ ] api/v1alpha1/validator.go validates all fields
- [ ] plugin/v1alpha1/plugin.go implements core logic
- [ ] xds/configurer.go generates Envoy config
- [ ] TargetRef supports correct kinds
- [ ] Both inbound and outbound rules handled
```

**XDS Generation:**
```
- [ ] Efficient resource aggregation in ResourceSet
- [ ] Proper listener/cluster/route configuration
- [ ] Protocol-specific handling (HTTP/TCP/GRPC)
- [ ] Metadata for debugging included
- [ ] Cache invalidation correct
```

**Multi-zone (KDS):**
```
- [ ] Global‚ÜíZone sync preserves resource integrity
- [ ] Zone‚ÜíGlobal status updates handled
- [ ] Version compatibility maintained
- [ ] Eventual consistency model respected
- [ ] Failure scenarios gracefully handled
```

#### 4. Testing Requirements

**Test Structure MUST follow:**
```go
var _ = Describe("Feature", func() {
    It("should behave correctly", func() {
        // setup
        manager := NewManager(...)

        // given
        input := Resource{...}

        // when
        result, err := manager.Process(input)

        // then
        Expect(err).ToNot(HaveOccurred())
        Expect(result).To(Equal(expected))
    })
})
```

**Coverage Requirements:**
```
- [ ] Unit tests for new functionality
- [ ] Table-driven tests for validators
- [ ] Golden files for Envoy configs
- [ ] Both K8s AND Universal mode tested
- [ ] E2E tests for user-facing features
- [ ] UPDATE_GOLDEN_FILES=true make test run if needed
```

#### 5. Performance

**Critical Paths:**
```
- [ ] XDS generation minimizes allocations
- [ ] Policy matching uses efficient algorithms
- [ ] Caching properly implemented (MeshContext)
- [ ] Database queries optimized
- [ ] Batch operations where possible
- [ ] No unnecessary goroutines
```

### Path-Specific Rules

```yaml
---
applyTo:
  - "pkg/plugins/policies/**/*.go"
---
# Policy Implementation
- Validator for all API fields
- Complete test coverage
- Follow api/plugin/xds structure
- TargetRef validation
- Protocol-specific handling

---
applyTo:
  - "pkg/xds/**/*.go"
---
# XDS Generation
- Efficient Envoy config
- Proper caching
- Resource aggregation
- Metadata for debugging
- No allocations in hot paths

---
applyTo:
  - "pkg/kds/**/*.go"
---
# Multi-zone Sync
- Consistency guarantees
- Version compatibility
- Failure handling
- Resource mapping correct
- Status propagation

---
applyTo:
  - "test/**/*.go"
---
# E2E Tests
- Both K8s and Universal
- Proper cleanup
- Idempotent
- Clear failure messages
- Reasonable timeouts
```

### CI Already Handles (Skip in Review)

```
‚úì Formatting (gofmt, gci)
‚úì Basic linting (golangci-lint)
‚úì Import ordering
‚úì Generated code consistency
‚úì Conventional commit format
‚úì License headers
```

### Examples

**üî¥ BLOCK Example:**
```
File: pkg/plugins/policies/meshretry/plugin/v1alpha1/plugin.go:42
Problem: Missing nil check before dereferencing pointer
Severity: Block - will cause panic in production
Fix: Add nil check before access
```

**üü° CHANGE Example:**
```
File: pkg/xds/generator/proxy_template.go:156
Problem: No test coverage for new edge case
Severity: Change - missing test for critical path
Fix: Add test case for empty cluster scenario
```

**üü¢ COMMENT Example:**
```
File: pkg/kds/reconcile/reconciler.go:89
Problem: Could batch these operations
Severity: Comment - performance optimization
Fix: Consider batching updates to reduce DB calls
```

### Anti-Patterns to Flag

**Always Flag:**
```go
// ‚ùå reflect.TypeOf for type checking
if reflect.TypeOf(err) == reflect.TypeOf(&NotFound{})

// ‚ùå Ignored errors
result, _ := process()

// ‚ùå Panic in production
if condition {
    panic("should not happen")
}

// ‚ùå Functions >50 lines
func veryLongFunction() { // 100+ lines
}

// ‚ùå Missing test comments
It("test", func() {
    // No setup/given/when/then markers
})
```

### Quick Reference

**Must Check:**
1. Security: mTLS, auth, secrets, validation
2. Correctness: xDS valid, policies match, KDS consistent
3. Testing: Unit + E2E, K8s + Universal, golden files
4. Performance: Allocations, caching, batching
5. Go standards: Errors wrapped, <50 lines, no reflect

**Confidence Thresholds:**
- 95%+: Block merge (security, breaking changes)
- 80%+: Request changes (tests, logic errors)
- 70%+: Comment only (style, minor optimizations)
- <70%: Skip (uncertain, let CI handle)

