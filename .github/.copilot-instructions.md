# Kuma Service Mesh

## Overview

CNCF service mesh (Envoy-based) for K8s/VMs. L4-L7 connectivity, security, observability, multi-zone/multi-mesh.

**Tech Stack:** Go 1.23+, Envoy, Kubernetes/VMs, Ginkgo/Gomega, protobuf, mise

**Purpose:** Universal service mesh supporting both Kubernetes and VMs with automatic mTLS, traffic control, observability, and multi-zone deployments. Built by Kong, donated to CNCF.

---

## Project Structure

```
/app/                    # Main apps (kuma-cp, kuma-dp, kumactl, cni, kuma-ui)
/pkg/
  core/                  # Resources, managers, validators, plugins
  xds/                   # Envoy xDS (cache, envoy/, server)
  kds/                   # Multi-zone sync (Kuma Discovery Service)
  plugins/policies/      # 20+ policies (api/, plugin/, xds/)
  config/api-server/dp-server/  # Config, APIs, servers
  test/                  # Test utilities, matchers, builders
/test/                   # E2E and integration tests
/docs/madr/              # Architecture Decision Records
```

**Key Modules:**
- **Control Plane** (`pkg/core/`, `app/kuma-cp/`) - xDS, mTLS, multi-zone
- **Policies** (`pkg/plugins/policies/<name>/`) - api/v1alpha1/, plugin/, xds/
- **XDS** (`pkg/xds/`) - Envoy config generation, dual-tier cache

**Code Generation:** Run `make generate` after changes to `.proto`, `pkg/plugins/policies/*/api/`, resource definitions. Generated: `zz_generated.*`, `*.pb.go`

---

## Development Workflow

**Before Coding:**
1. ASK questions until 95% confident
2. Search for similar implementations (Grep/Glob)
3. Read existing code in relevant `pkg/` directory
4. Create plan, get approval (use Plan Mode for complex tasks)
5. Work incrementally (20-50 lines per step)

**Process:**
1. `make check` - clean state (ONLY for code changes, skip for config/docs/CI)
2. Read existing code
3. Write tests first (`*_test.go`, Ginkgo/Gomega)
4. Implement minimal changes
5. `make check && make test` - validate

---

## Go Conventions

### Error Handling

```go
// Custom error types with Is() - NO reflect.TypeOf
func (e *NotFound) Is(err error) bool {
    _, ok := err.(*NotFound)  // Use type assertion
    return ok
}

// Wrap with context
return errors.Errorf("failed to create dataplane: %w", err)

// Type assertions with clear messages
if !ok {
    return errors.Errorf("invalid type: expected=%T, got=%T", expectedType, actualType)
}

// Multi-error (transactions)
import "go.uber.org/multierr"
return multierr.Append(errors.Wrap(rollbackErr, "rollback failed"), err)
```

**Rules:** Always wrap errors • Use custom types with `Is()` • NO `reflect.TypeOf()` • Check `context.Canceled` before rollback • Use `multierr` for multiple errors

### Naming & Organization

**Naming:** Unexported types (`dataplaneManager`) • Exported interfaces (`ResourceManager`) • Descriptive constants

**Patterns:**
- Embedded interfaces for composition: `struct { ResourceManager; store Store }`
- Strategy pattern: `type TimeoutConfigurer struct {...}; func (t) Configure(cluster) error`
- Context propagation: `type ctxKey struct{}`; `context.WithValue(ctx, ctxKey{}, val)`
- Builder for tests: `Dataplane().WithName("x").Build()`

**Comments:** Public APIs only • Explain "why" not "what" • Test markers: `// setup`, `// given`, `// when`, `// then`

### Linter Errors

**Formatter:** `gofmt` (auto via `make check`)
**Linter:** `golangci-lint` (config: `.golangci.yml`)

**ALWAYS:**
- Attempt to fix linter errors properly
- Research solutions online if unclear how to fix
- Fix root cause, not symptoms

**NEVER:**
- Use skip/disable directives (`//nolint`, `// revive:disable`)
- Ignore linter warnings
- Work around linter errors

**If stuck:**
1. Try fixing the error
2. Research online for proper solution
3. If still unclear after research, ASK what to do (don't skip/disable)

---

## Simplicity Principles

### Anti-Patterns to AVOID

❌ **NEVER:**
- Long functions (>50 lines per function)
- Over-engineering (unnecessary abstractions/configurers)
- `reflect.TypeOf()` for type checking
- Generic `interface{}` instead of typed maps
- Panics in production code
- Entire files at once
- Placeholders `// ... rest of code ...`

✅ **ALWAYS:**
- Functions <50 lines, single responsibility
- Search existing patterns FIRST (Grep/Glob)
- Three similar lines > premature abstraction
- Minimal, surgical changes
- Reuse existing components

**Check before implementing:**
1. Does similar code exist? What pattern does it use?
2. Can this be simpler/shorter?
3. Am I following existing plugin/configurer/manager pattern?
4. Is this minimal change to achieve goal?

---

## Code Generation Rules

### NEVER

- Generate long functions (>50 lines per function)
- Generate entire files at once (>100 lines in single response)
- Make big changes in single step
- Use placeholders like `// ... rest of code ...`
- Modify code unrelated to the task
- Assume requirements without asking
- Add features beyond what's requested

### ALWAYS

- Show complete code (no placeholders)
- Incremental changes (20-50 lines per step)
- Surgical, minimal changes only
- Test-driven development (write tests first)
- Follow existing patterns found in codebase
- Ask questions before assuming requirements

### Incremental Development Process

**Break changes into steps:**
1. Define interfaces/types
2. Write tests (input/output pairs)
3. Implement core logic (minimal)
4. Add error handling
5. Run tests, iterate
6. Update golden files if needed

**Each step:** Review, test, approve, then proceed to next.

---

## Testing

### Testing with Ginkgo/Gomega

**Structure:**
```go
var _ = Describe("Feature", func() {
    It("should behave correctly", func() {
        // setup
        manager := NewManager(...)

        // given
        input := Resource{...}

        // when
        err := manager.Create(ctx, &input, key)
        Expect(err).ToNot(HaveOccurred())

        // then
        Expect(actual.Field).To(Equal("expected"))
    })
})
```

**Table-driven:**
```go
DescribeTable("should validate",
    func(yaml string) {
        err := FromYAML([]byte(yaml), &spec)
        Expect(err).ToNot(HaveOccurred())
    },
    Entry("full", `targetRef: ...`),
    Entry("minimal", `targetRef: {kind: Mesh}`),
)
```

**Golden Files:**
```go
Expect(yaml).To(matchers.MatchGoldenYAML("testdata", "file.yaml"))
// Update: UPDATE_GOLDEN_FILES=true make test
```

**Builders:**
```go
dp := test_builders.Dataplane().WithName("dp1").Build()  // Validates, panics on error
```

**Common Mistakes:** ❌ Missing flow comments • Not updating golden files • No validation in builders • Using `err == nil` instead of Gomega matchers

---

## Commands & Git

### Development

```bash
make install              # mise install
make build                # Build all
make check                # Lint/format (auto-fix)
make generate             # Gen code (proto, policies, resources)
make test                 # Run tests
make test/e2e             # E2E (slow)

make build/kuma-cp        # Build control plane
make test TEST_PKG_LIST=./pkg/xds/...    # Test specific package
UPDATE_GOLDEN_FILES=true make test       # Update golden files

make k3d/restart && skaffold dev          # Dev environment
```

### Git & PRs

```bash
git push --no-verify upstream branch    # ALWAYS use --no-verify
```

**Branches:** `master` (base), `release-{2.7,2.10,2.11,2.12}`
**Versions:** 2.7.19 (LTS), 2.10.8, 2.11.7, 2.12.3

**Commit Format:** [Conventional Commits](https://www.conventionalcommits.org/)
```
<type>(<scope>): <subject>

<body>

Fixes #123
```

**Types:** `feat`, `fix`, `chore`, `docs`, `test`, `refactor`, `ci`
**Scopes:** `kuma-cp`, `kuma-dp`, `kumactl`, `xds`, `kds`, `MeshRetry`, `api-server`
**Sign:** Use `-s -S` flags

**PR:** Base: `master` • Template: `.github/PULL_REQUEST_TEMPLATE.md` • Changelog: from title or `> Changelog:` • Labels: `ci/*` at creation • MADR: `docs/madr/decisions/000-template.md` • No Kong Mesh mentions (use "downstream project")

---

## Architecture & Domain

### Components

- **kuma-cp** - Control plane (xDS, mTLS, multi-zone coordinator)
- **kuma-dp** - Data plane (Envoy wrapper)
- **kumactl** - CLI
- **kuma-cni** - CNI plugin

**Multi-zone:** Global CP → Zone CPs via KDS • Zone Ingress/Egress for cross-zone • K8s + Universal (VMs)

### Core Concepts

| Term | Definition | Usage |
|------|------------|-------|
| **Dataplane** | Envoy proxy instance per workload | Sidecar for each pod/VM |
| **Mesh** | Isolated namespace for resources | `default` mesh, can have multiple |
| **ZoneTag** | `kuma.io/zone` auto-added by CP | Marks dataplane origin zone |
| **TargetRef** | Policy selector | `Mesh`, `MeshService`, `MeshSubset` |
| **FromRules** | Inbound policies | TrafficPermission from services |
| **ToRules** | Outbound policies | RetryPolicy to dependencies |
| **MeshContext** | Cached config for xDS | Dual-tier cache (short TTL + hash) |
| **xDS** | Envoy discovery protocol | CDS/EDS/LDS/RDS |
| **KDS** | Kuma Discovery Service | Multi-zone sync |
| **Configurer** | Strategy for Envoy config | `TimeoutConfigurer`, `CircuitBreakerConfigurer` |
| **MatchedPolicies** | Policies for a dataplane | Based on TargetRef selectors |

### Policy Structure

```
pkg/plugins/policies/<policy-name>/
  api/v1alpha1/           # <policy>_types.go, validator.go
  plugin/v1alpha1/        # plugin.go (application logic)
  xds/                    # configurer.go (Envoy config)
```

**Example:**
```yaml
apiVersion: kuma.io/v1alpha1
kind: MeshTimeout
spec:
  targetRef: {kind: MeshService, name: backend}
  to:
    - targetRef: {kind: MeshService, name: db}
      default: {connectionTimeout: 5s, idleTimeout: 60s}
```

### xDS Protocol

**CDS** (Clusters) - Backend services
**EDS** (Endpoints) - Service endpoints
**LDS** (Listeners) - Inbound/outbound listeners
**RDS** (Routes) - HTTP routes

---

## Complexity Hotspots

| Area | Location | Challenge |
|------|----------|-----------|
| **Policy Matching** | `pkg/plugins/policies/core/matchers/` | Selector evaluation, wildcards, cross-zone |
| **XDS Generation** | `pkg/xds/generator/`, `pkg/xds/envoy/` | Merging policies, precedence, protocol-specific |
| **Multi-zone Sync** | `pkg/kds/` | Eventual consistency, failures, versioning |
| **Rule Resolution** | `pkg/plugins/policies/core/rules/` | Inbound/outbound, subsets, precedence |

**Tips:**
- Study existing matchers/configurers before adding new logic
- Use strategy pattern, keep configurers focused (single concern)
- Test K8s + Universal modes
- Validate mesh isolation and policy boundaries

---

## Gotchas & Debugging

### Common Issues

**Build:** `make install` (dependencies) • `make generate` (outdated code) • `make check` (formatting)
**Test:** `UPDATE_GOLDEN_FILES=true make test` (golden mismatch) • `make test/e2e` (cluster setup)
**Multi-zone:** Test K8s + Universal • Verify isolation • Validate cross-zone carefully

### Debugging

**Temp logs:** Prefix "DEBUG" for easy removal

**Envoy config:**
```bash
kubectl exec deploy/<name> -c kuma-sidecar -- \
  wget -qO- localhost:9901/config_dump | jq '.configs[]'
```

### Performance & Security

**Performance:** Minimize allocations (many dataplanes) • Optimize DB queries • XDS efficiency critical
**Security:** Validate external inputs • Careful with mTLS/certs • Follow RBAC implications • Secure secrets handling

### Tool Management

**mise:** Config: `mise.toml` • Pinned versions • `make install` or `mise install`
**Tools:** buf, ginkgo, helm, kind, kubectl, protoc, yq, golangci-lint, skaffold

---

## Resources

- **DEVELOPER.md** - Setup, testing details
- **CONTRIBUTING.md** - PR workflow, commit format
- **docs/madr/decisions/** - Architecture decisions
- **Kuma Docs** - https://kuma.io/docs
- **Slack** - https://kuma-mesh.slack.com
