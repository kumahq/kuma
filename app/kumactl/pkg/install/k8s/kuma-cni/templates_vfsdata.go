// Code generated by vfsgen; DO NOT EDIT.

// +build !dev

package kumacni

import (
	"bytes"
	"compress/gzip"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"os"
	pathpkg "path"
	"time"
)

// Templates statically implements the virtual filesystem provided to vfsgen.
var Templates = func() http.FileSystem {
	fs := vfsgen۰FS{
		"/": &vfsgen۰DirInfo{
			name:    "/",
			modTime: time.Date(2020, 4, 19, 17, 47, 43, 718178024, time.UTC),
		},
		"/all-in-one-template.yaml": &vfsgen۰CompressedFileInfo{
			name:             "all-in-one-template.yaml",
			modTime:          time.Date(2020, 4, 19, 17, 47, 43, 718050961, time.UTC),
			uncompressedSize: 3784,

			compressedContent: []byte("\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\xff\xa4\x56\x4d\x6f\xdb\xba\x12\xdd\xfb\x57\x0c\xdc\x45\x37\x91\xf4\x8a\x87\x07\x14\x7a\xab\xd4\x4d\x53\x23\x8d\x1a\x24\xcd\xbd\x8b\xa2\x10\xc6\xe4\xd8\xe2\x35\xc5\x11\x48\xca\x89\xdb\x9b\xff\x7e\x41\x7d\x38\x92\x3f\xd2\xa2\x57\x0b\x1b\x12\x67\xce\x1c\xce\x0c\x0f\x27\x8a\xa2\x09\x56\xea\x0f\xb2\x4e\xb1\x49\x61\xf3\x66\xb2\x56\x46\xa6\x70\x47\x76\xa3\x04\x9d\x0b\xc1\xb5\xf1\x93\x92\x3c\x4a\xf4\x98\x4e\x00\x0c\x96\x94\xc2\xba\x2e\x31\x12\x46\x75\x1f\x5c\x85\xa2\xf9\xba\xa0\xc8\x6d\x9d\xa7\x72\x02\xa0\x71\x41\xda\x05\x1f\x00\xac\xaa\x81\x53\x88\xdb\x06\x9a\xb1\x59\xaa\xd5\x35\x56\xfb\x3c\x4e\x87\x8c\x44\xe3\xf3\x7b\x91\x7b\xc8\x57\xf0\xa5\x20\x98\x65\x73\x30\xe4\x1f\xd8\xae\xa1\x45\xad\x2d\x7a\xc5\x06\x3c\x03\x4a\x19\xfe\x7c\x41\x50\xe9\x7a\xa5\x0c\x88\x02\x95\x01\x36\x40\x28\x0a\x30\x2c\x29\x86\x06\xc7\x55\x24\x14\xea\x06\x77\x83\xba\x26\x07\xca\x80\x2f\x94\xeb\x60\xe1\x41\x69\x0d\x0b\x02\xac\x3d\x97\xe8\x95\x40\xad\xb7\x50\x71\x55\x6b\xf4\x24\xe3\x09\x80\x30\x2a\xef\xc8\xe4\xad\x57\x0a\x7f\x47\xcd\x1e\x7e\x34\xbf\x00\x53\x61\xfa\x24\x4d\x53\x98\xfe\x27\xfe\x6f\xfc\x66\x7a\xd6\x2f\x86\x74\x84\xcf\xfd\x66\x9f\x57\xfc\xb6\x3a\xb1\xa2\x79\x95\x6b\xda\x90\x0e\xcb\xca\x2c\xf9\x79\x29\xa4\xd4\x1a\xf2\xe4\xa6\xe9\x8e\xc1\x6e\xa5\x65\x18\xbc\xf2\xfc\xea\xfe\xdd\xc5\xec\x73\xf6\x61\x7e\x99\x7f\x98\x7f\xba\xb8\x39\xff\xf2\x31\xcf\x77\x40\x3d\xf1\x7c\xa1\x4c\x2e\x95\x0d\x3e\xc9\x06\x6d\xa2\xd5\x22\x11\x46\x25\x0b\x65\xc6\xc6\xf4\x28\x74\x2d\x29\xdf\xd5\x37\x30\xf8\xda\xc6\xed\x8a\x3c\x85\x6f\x9d\xc7\xd3\xa4\xfd\xdd\xef\x65\xbb\x40\x11\x63\xed\x0b\xb6\xea\x7b\x53\xd4\x78\xfd\xd6\xc5\x8a\x93\x5d\x97\xcf\x74\xed\x3c\xd9\x5b\xd6\xf4\x72\x8b\x9f\xee\x27\x5b\x6b\x6a\x16\x22\xc0\x4a\x5d\x5a\xae\x2b\x97\xc2\xd7\xe9\xb4\xa5\x67\xc9\x71\x6d\x05\x75\xbe\xc1\xac\x62\xe9\x76\x2f\xa1\x87\xda\xb7\x0d\xd9\xc5\xc0\x6a\x45\xfe\x5f\xee\xe8\x9d\x32\x52\x99\xd5\x6f\x6f\x8c\x35\xdd\xd2\x32\x2c\xf5\x1b\x7b\x81\xc1\x04\xe0\x30\xa5\x07\xf1\x5c\xbd\xf8\x8b\x84\xef\xf2\x75\x54\x69\x02\x91\x03\x96\x27\x4f\xfa\xb3\x8e\xbc\x47\x2a\xd9\xdc\x91\x1f\x65\x0c\xab\xca\x25\x2f\x8b\x49\xa8\xc0\xaf\x4a\xc9\xfa\xad\x8b\x46\x59\x6a\xbd\xc3\xe9\x0f\x06\x8e\x34\x09\xcf\xb6\x35\x2e\xd1\x8b\xe2\xd3\xc0\xfb\xa4\x3f\x40\x5d\x49\xf4\x74\xe7\x2d\x7a\x5a\x6d\x5b\xf3\x70\x66\x53\xb8\x65\xad\x95\x59\xdd\x37\x06\x6d\x4b\x0d\xbf\xf4\xc8\x25\x3e\xde\x1b\xdc\xa0\xd2\xb8\xd0\x94\xc2\x9b\x09\x80\xa7\xb2\xd2\x3b\x9b\x61\x0a\xc2\xa3\x47\xcc\x5e\xe0\xd6\xb4\x86\x31\xec\x9b\x7a\x0f\x3c\x82\x84\x2a\x77\x06\xa8\xd9\x04\x81\xf3\x45\xa3\x95\x33\xab\x1a\x79\x3b\x97\x92\x8d\xfb\x6c\xf4\x16\x3c\x6b\xea\x74\x75\x41\x9a\x1f\xce\x06\x18\x25\xda\xb5\x6b\x45\x96\x25\xa0\x03\x04\xd1\x21\x04\x05\x8e\xd8\x9c\x01\x19\x57\x5b\x65\x56\xa0\x7c\x38\x18\x6e\xe0\x5e\x59\xc5\x56\xf9\x2d\x38\x51\x90\xac\x43\x66\x00\x8d\x04\x5f\xa0\x07\xe5\xdd\xf3\x09\x04\xb4\x14\xde\xc8\x6e\x48\x0e\x10\xd4\x32\xc0\xd2\x86\x6c\x83\x0d\xb4\x51\xa2\x53\xe4\xf6\xe9\x90\xc9\xc6\xa8\xab\x02\xe3\x67\x5d\x0c\x47\xaf\x27\x1b\x55\x2c\x53\x78\xfd\xba\x71\xeb\x3b\xa2\x69\x5d\x96\x74\x37\xea\x8c\xf0\x2c\xc8\xef\x23\xb1\x4b\x41\x2b\x53\x3f\x76\x46\x05\x3b\x9f\xb5\xf7\x41\x0a\xde\xd6\x7d\x31\x9e\xb3\x39\x2a\xc6\x35\xae\x09\x5c\x6d\x69\x5c\xc1\x76\x53\xfd\x1e\x64\xb8\xbd\x50\xeb\x56\x78\x9e\xf7\x18\x01\x2d\x97\x24\x7c\x0a\x19\xdf\x75\xb6\x03\x45\xe6\x2a\x44\x64\x9b\xc2\xc5\xa3\x72\xa3\x02\x5c\xa3\x5d\xbf\x58\x3e\x58\xb2\x0d\x79\xdf\xd5\x67\x18\x75\x4d\xdb\xf4\x48\xc7\xfc\x4a\xe8\x21\xe5\x8b\x47\x12\xb5\xff\x05\xc6\x7d\xbb\xcc\x34\x3a\x97\x35\x4a\xd0\x9e\xf4\x48\xb4\xc2\x15\xf5\xec\x3b\x07\x37\x92\xa7\xec\x50\x99\x9a\x1c\x28\xa3\x4a\xf5\x9d\x40\xf2\x83\xf1\xaa\x24\x90\x6d\xbf\x62\x7f\x5a\xa1\xae\x56\x16\x25\x01\x5b\x90\xa4\x29\x54\xef\xff\xe0\x49\x6b\xb8\xda\x35\x41\x98\x36\x24\x03\xc2\x74\xc9\x56\xd0\x0e\xbe\x77\x98\xa6\x50\x78\x5f\xb9\x34\x49\xc6\x9d\x23\x59\xb8\x44\xb0\x11\x54\x79\x97\x84\x86\xd1\x8c\xd2\x25\xe1\xaa\x09\x3f\xc9\x2b\x4f\xb6\x54\xa6\x69\x9a\x88\x97\xa1\x57\x77\xc5\x1f\x2c\x5d\x5a\x14\x74\x43\x56\xb1\xbc\x0b\x17\xbc\x74\x29\xfc\xaf\x33\x13\x6c\x3c\x2a\x43\x76\xd0\x74\x51\x27\xa6\xca\x38\x8f\x5a\x0f\x72\x12\x1e\x55\xe2\x8a\x52\xf8\xf1\x03\xe2\x59\x36\x9f\x87\x37\x78\x7a\x4a\x9b\x77\x36\xde\xb2\xbe\xd1\x68\xa8\x13\x6b\x78\x7a\xda\xf7\xbd\xa9\xb5\xbe\x61\xad\xc4\x36\x85\x73\xfd\x80\x5b\x37\xb0\x10\x5c\x96\x18\x94\xff\xeb\x34\x19\xc4\x8f\x5d\x31\xfd\x36\x30\x23\xb3\x49\x07\xaf\x21\x9d\xa1\x88\xc0\xcb\x56\xac\xb2\x79\x3f\xa1\x2d\x95\xa6\x50\x01\x61\x09\x3d\xc5\x23\xa7\x7e\xa3\xb3\x6c\x9e\x87\x41\x27\xcf\xce\xaf\x2f\x46\x16\xd0\xce\x7d\x83\x19\x2b\x0e\xb8\xd3\xbd\xd8\xc7\x87\xce\x10\xb6\xdb\xc3\x78\xba\x3c\x49\x22\xbb\xf8\xf2\xe7\xe7\xdb\xab\xbc\x9d\xba\x8e\x31\xf9\x60\xb9\x4c\xf7\x16\xa0\x8b\x77\x8d\xd5\x15\x6d\xbb\xdb\x7d\xff\x39\x35\x6c\xef\x3f\xcd\xd1\x3d\x9c\x59\x5f\xa2\x9c\xbf\x9f\xdf\x1e\xcf\x5a\x42\x5e\x34\xb3\x60\x59\x6b\x5f\xbb\xc4\x90\x8f\xe5\x5e\xee\xe6\xcb\x46\x05\xcf\x40\x52\xa5\x79\xdb\x89\x4d\x18\xc9\x49\x36\x49\x6d\xa7\xf4\x33\x60\x5f\x90\x7d\x50\x8e\x46\x96\xce\xa3\x91\xe1\xae\x6a\x2a\x70\x9c\xe6\xc7\xf3\x79\x76\xf1\x3e\x0f\x74\x6f\x3e\xdd\x5f\xce\xb3\x13\x35\x5e\xa2\x76\x34\xac\xed\x86\x75\x5d\xd2\x75\xd0\x08\x97\xee\x61\x97\xe1\xeb\x0d\xfa\x22\x85\x24\x68\x7a\xc2\x95\xef\xe7\xde\xc9\xb1\xdc\x87\xb4\x2f\x94\x89\xa4\xb2\x3f\x83\xea\xd3\x76\x98\xaf\x21\x98\x21\x3f\x00\x6b\xb9\x8e\xee\x8e\x7b\x47\x72\xd8\x84\xb3\x6c\x1e\x1f\x9c\xf2\xe3\xb4\x02\x8d\x86\xd1\x28\x7a\xd5\x72\xdc\x9b\xf2\x8f\x42\x8e\xc9\xfd\x14\xf2\x68\xa3\xfc\x13\x00\x00\xff\xff\xf1\x53\x51\x4a\xc8\x0e\x00\x00"),
		},
	}
	fs["/"].(*vfsgen۰DirInfo).entries = []os.FileInfo{
		fs["/all-in-one-template.yaml"].(os.FileInfo),
	}

	return fs
}()

type vfsgen۰FS map[string]interface{}

func (fs vfsgen۰FS) Open(path string) (http.File, error) {
	path = pathpkg.Clean("/" + path)
	f, ok := fs[path]
	if !ok {
		return nil, &os.PathError{Op: "open", Path: path, Err: os.ErrNotExist}
	}

	switch f := f.(type) {
	case *vfsgen۰CompressedFileInfo:
		gr, err := gzip.NewReader(bytes.NewReader(f.compressedContent))
		if err != nil {
			// This should never happen because we generate the gzip bytes such that they are always valid.
			panic("unexpected error reading own gzip compressed bytes: " + err.Error())
		}
		return &vfsgen۰CompressedFile{
			vfsgen۰CompressedFileInfo: f,
			gr:                        gr,
		}, nil
	case *vfsgen۰DirInfo:
		return &vfsgen۰Dir{
			vfsgen۰DirInfo: f,
		}, nil
	default:
		// This should never happen because we generate only the above types.
		panic(fmt.Sprintf("unexpected type %T", f))
	}
}

// vfsgen۰CompressedFileInfo is a static definition of a gzip compressed file.
type vfsgen۰CompressedFileInfo struct {
	name              string
	modTime           time.Time
	compressedContent []byte
	uncompressedSize  int64
}

func (f *vfsgen۰CompressedFileInfo) Readdir(count int) ([]os.FileInfo, error) {
	return nil, fmt.Errorf("cannot Readdir from file %s", f.name)
}
func (f *vfsgen۰CompressedFileInfo) Stat() (os.FileInfo, error) { return f, nil }

func (f *vfsgen۰CompressedFileInfo) GzipBytes() []byte {
	return f.compressedContent
}

func (f *vfsgen۰CompressedFileInfo) Name() string       { return f.name }
func (f *vfsgen۰CompressedFileInfo) Size() int64        { return f.uncompressedSize }
func (f *vfsgen۰CompressedFileInfo) Mode() os.FileMode  { return 0444 }
func (f *vfsgen۰CompressedFileInfo) ModTime() time.Time { return f.modTime }
func (f *vfsgen۰CompressedFileInfo) IsDir() bool        { return false }
func (f *vfsgen۰CompressedFileInfo) Sys() interface{}   { return nil }

// vfsgen۰CompressedFile is an opened compressedFile instance.
type vfsgen۰CompressedFile struct {
	*vfsgen۰CompressedFileInfo
	gr      *gzip.Reader
	grPos   int64 // Actual gr uncompressed position.
	seekPos int64 // Seek uncompressed position.
}

func (f *vfsgen۰CompressedFile) Read(p []byte) (n int, err error) {
	if f.grPos > f.seekPos {
		// Rewind to beginning.
		err = f.gr.Reset(bytes.NewReader(f.compressedContent))
		if err != nil {
			return 0, err
		}
		f.grPos = 0
	}
	if f.grPos < f.seekPos {
		// Fast-forward.
		_, err = io.CopyN(ioutil.Discard, f.gr, f.seekPos-f.grPos)
		if err != nil {
			return 0, err
		}
		f.grPos = f.seekPos
	}
	n, err = f.gr.Read(p)
	f.grPos += int64(n)
	f.seekPos = f.grPos
	return n, err
}
func (f *vfsgen۰CompressedFile) Seek(offset int64, whence int) (int64, error) {
	switch whence {
	case io.SeekStart:
		f.seekPos = 0 + offset
	case io.SeekCurrent:
		f.seekPos += offset
	case io.SeekEnd:
		f.seekPos = f.uncompressedSize + offset
	default:
		panic(fmt.Errorf("invalid whence value: %v", whence))
	}
	return f.seekPos, nil
}
func (f *vfsgen۰CompressedFile) Close() error {
	return f.gr.Close()
}

// vfsgen۰DirInfo is a static definition of a directory.
type vfsgen۰DirInfo struct {
	name    string
	modTime time.Time
	entries []os.FileInfo
}

func (d *vfsgen۰DirInfo) Read([]byte) (int, error) {
	return 0, fmt.Errorf("cannot Read from directory %s", d.name)
}
func (d *vfsgen۰DirInfo) Close() error               { return nil }
func (d *vfsgen۰DirInfo) Stat() (os.FileInfo, error) { return d, nil }

func (d *vfsgen۰DirInfo) Name() string       { return d.name }
func (d *vfsgen۰DirInfo) Size() int64        { return 0 }
func (d *vfsgen۰DirInfo) Mode() os.FileMode  { return 0755 | os.ModeDir }
func (d *vfsgen۰DirInfo) ModTime() time.Time { return d.modTime }
func (d *vfsgen۰DirInfo) IsDir() bool        { return true }
func (d *vfsgen۰DirInfo) Sys() interface{}   { return nil }

// vfsgen۰Dir is an opened dir instance.
type vfsgen۰Dir struct {
	*vfsgen۰DirInfo
	pos int // Position within entries for Seek and Readdir.
}

func (d *vfsgen۰Dir) Seek(offset int64, whence int) (int64, error) {
	if offset == 0 && whence == io.SeekStart {
		d.pos = 0
		return 0, nil
	}
	return 0, fmt.Errorf("unsupported Seek in directory %s", d.name)
}

func (d *vfsgen۰Dir) Readdir(count int) ([]os.FileInfo, error) {
	if d.pos >= len(d.entries) && count > 0 {
		return nil, io.EOF
	}
	if count <= 0 || count > len(d.entries)-d.pos {
		count = len(d.entries) - d.pos
	}
	e := d.entries[d.pos : d.pos+count]
	d.pos += count
	return e, nil
}
