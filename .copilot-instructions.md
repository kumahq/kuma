# Kuma Service Mesh - GitHub Copilot Instructions

## Project Overview

Kuma is a modern, universal service mesh that runs on both Kubernetes and VMs. It's a CNCF Sandbox project written in Go that uses Envoy as its data plane proxy. Kuma provides service connectivity, security, observability, and traffic management across multi-zone and multi-mesh deployments.

### Key Architecture Components

- **Control Plane (`kuma-cp`)**: Manages service mesh configuration and policies
- **Data Plane (`kuma-dp`)**: Envoy-based proxy that handles service traffic  
- **CLI Tool (`kumactl`)**: Command-line interface for mesh management
- **Multi-zone support**: Cross-cluster and cross-cloud service mesh capabilities
- **Universal mode**: Support for both Kubernetes and VM/bare metal deployments

## Development Workflow

### Essential Commands

Before making any changes, always run these commands to understand the current state:

```bash
# Install development dependencies
make install

# Run code formatting, linting, and validation
make check

# Run all tests
make test

# Run tests for specific components
make test/kumactl
make test/kuma-cp
make test/kuma-dp

# Generate code (protobuf, resources, policies)
make generate

# Update test golden files when test assertions change
make test UPDATE_GOLDEN_FILES=1

# Build all binaries
make build

# Build specific binary
make build/kumactl
```

### Testing Framework

- **Framework**: Uses [Ginkgo](https://github.com/onsi/ginkgo) BDD testing framework
- **Golden Files**: Many tests use golden file assertions that capture expected output
- **E2E Tests**: Large integration tests (`make test/e2e`) - run these carefully as they're slow
- **Update Golden Files**: When changing expected test output, run `make test UPDATE_GOLDEN_FILES=1`

### Code Organization

```
pkg/
├── core/           # Core service mesh logic
├── config/         # Configuration management
├── xds/            # Envoy xDS API implementation  
├── kds/            # Kuma Discovery Service
├── api-server/     # REST API server
├── dp-server/      # Data plane server
├── plugins/        # Plugin architecture
├── policies/       # Service mesh policies
└── test/           # Test utilities and matchers
```

## Development Guidelines

### Code Style & Quality

- **Always run `make check`** before committing - this runs formatting, linting, and validation
- **Follow Go conventions**: Use `gofmt`, respect `golangci-lint` rules
- **Write tests**: Include unit tests for new functionality using Ginkgo
- **Update golden files**: If your changes affect test output, update golden files with `UPDATE_GOLDEN_FILES=1`

### Making Changes

1. **Start with formatting**: Run `make check` to ensure clean starting state
2. **Understand the component**: Read existing code in the relevant `pkg/` subdirectory
3. **Write tests first**: Add test cases in `*_test.go` files using Ginkgo
4. **Implement changes**: Make minimal, focused changes
5. **Validate thoroughly**: Run `make check && make test` before submitting

### Working with Policies

When working on service mesh policies:

- Policy definitions are in `pkg/plugins/policies/`
- Generate code after policy changes: `make generate`  
- Update API documentation: Policies often affect OpenAPI specs
- Test with both Kubernetes and Universal mode

### Working with XDS/Envoy Integration

- XDS server code is in `pkg/xds/`
- Envoy configuration templates in `pkg/xds/envoy/`
- Test with actual Envoy when possible using e2e tests
- Be mindful of Envoy version compatibility

### Golden Files & Test Assertions

Golden files capture expected test output for validation:

```go
// Example golden file usage
Expect(actualOutput).To(matchers.MatchGoldenYAML("testdata", "expected-output.yaml"))
```

- **Location**: Usually in `testdata/` directories alongside tests
- **Updates**: Use `make test UPDATE_GOLDEN_FILES=1` to update all golden files
- **Careful review**: Always review golden file changes to ensure they're correct

## Common Issues & Solutions

### Build Issues
- **Missing dependencies**: Run `make install` to install dev tools via mise
- **Outdated generated code**: Run `make generate` to regenerate protobuf and other generated files
- **Formatting errors**: Run `make check` - this will often auto-fix formatting issues

### Test Issues  
- **Golden file mismatches**: Run `make test UPDATE_GOLDEN_FILES=1` to update expected output
- **E2E test failures**: These are integration tests - ensure you have proper cluster setup
- **Flaky tests**: Some tests depend on timing - run multiple times to verify

### Multi-zone/Multi-mesh Complexity
- **Zone configuration**: Test cross-zone functionality carefully
- **Mesh isolation**: Ensure policies respect mesh boundaries
- **Universal vs K8s**: Test both deployment modes when relevant

## Performance Considerations

- **Memory usage**: Kuma handles large numbers of data planes - be mindful of memory allocations
- **XDS efficiency**: Changes to XDS can affect data plane update performance  
- **Database operations**: Control plane uses database - optimize queries
- **Concurrent access**: Service mesh components must handle high concurrency

## Security Guidelines

- **mTLS handling**: Be careful with certificate management code
- **RBAC policies**: Understand access control implications
- **Input validation**: Always validate external inputs, especially in API server
- **Secrets management**: Follow secure practices for handling sensitive data

## Useful Resources

- **[DEVELOPER.md](DEVELOPER.md)**: Comprehensive development setup guide
- **[CONTRIBUTING.md](CONTRIBUTING.md)**: Contribution guidelines and workflow
- **Main documentation**: https://kuma.io/docs
- **Community Slack**: https://kuma-mesh.slack.com
- **Architecture docs**: `docs/` directory for design documents

## Getting Help

- **Community Slack**: Join #kuma-mesh for questions and discussions
- **GitHub Issues**: For bug reports and feature requests
- **Code Review**: Maintainers are helpful in PR reviews
- **Documentation**: Extensive docs at kuma.io cover most use cases

Remember: Kuma is a complex distributed system. Take time to understand the component you're working on, write comprehensive tests, and don't hesitate to ask questions in the community!