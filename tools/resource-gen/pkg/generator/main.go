package generator

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"log"
	"os"
	"path"
	"path/filepath"
	"reflect"
	"sort"
	"strings"
	"text/template"
	"unicode"
	"unicode/utf8"

	"github.com/invopop/jsonschema"
	orderedmap "github.com/wk8/go-ordered-map/v2"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/reflect/protoregistry"
	"google.golang.org/protobuf/types/known/structpb"
	"google.golang.org/protobuf/types/known/wrapperspb"
	"sigs.k8s.io/yaml"

	"github.com/kumahq/kuma/v2/api/mesh/v1alpha1"
	system_proto "github.com/kumahq/kuma/v2/api/system/v1alpha1"
	builtin_config "github.com/kumahq/kuma/v2/pkg/plugins/ca/builtin/config"
	provided_config "github.com/kumahq/kuma/v2/pkg/plugins/ca/provided/config"
	"github.com/kumahq/kuma/v2/pkg/util/maps"
	commontemplate "github.com/kumahq/kuma/v2/tools/common/template"
	"github.com/kumahq/kuma/v2/tools/common/types"
	. "github.com/kumahq/kuma/v2/tools/resource-gen/genutils"
)

// CustomResourceTemplate for creating a Kubernetes CRD to wrap a Kuma resource.
var CustomResourceTemplate = template.Must(template.New("custom-resource").Parse(`
// Generated by tools/resource-gen. DO NOT EDIT.
// Run "make generate" to update this file.

{{ $pkg := printf "%s_proto" .Package }}
{{ $tk := "\u0060" }} {{/* Backtick */}}

package v1alpha1

import (
	"errors"
	"fmt"

	apiextensionsv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	{{ $pkg }} "github.com/kumahq/kuma/v2/api/{{ .Package }}/v1alpha1"
	core_model "github.com/kumahq/kuma/v2/pkg/core/resources/model"
	"github.com/kumahq/kuma/v2/pkg/plugins/resources/k8s/native/pkg/model"
	"github.com/kumahq/kuma/v2/pkg/plugins/resources/k8s/native/pkg/registry"
	util_proto "github.com/kumahq/kuma/v2/pkg/util/proto"
)

{{range .Resources}}
{{- if not .SkipKubernetesWrappers }}

// +kubebuilder:object:root=true
{{- if .ScopeNamespace }}
// +kubebuilder:resource:categories=kuma,scope=Namespaced{{- if ne .ShortName ""}},shortName={{.ShortName}}{{- end}}
{{- else }}
// +kubebuilder:resource:categories=kuma,scope=Cluster{{- if ne .ShortName ""}},shortName={{.ShortName}}{{- end}}
{{- end}}
{{- range .AdditionalPrinterColumns }}
// +kubebuilder:printcolumn:{{ . }}
{{- end}}
type {{.ResourceType}} struct {
	metav1.TypeMeta   {{ $tk }}json:",inline"{{ $tk }}
	metav1.ObjectMeta {{ $tk }}json:"metadata,omitempty"{{ $tk }}

    // Mesh is the name of the Kuma mesh this resource belongs to.
	// It may be omitted for cluster-scoped resources.
	//
    // +kubebuilder:validation:Optional
	Mesh string {{ $tk }}json:"mesh,omitempty"{{ $tk }}

{{- if eq .ResourceType "DataplaneInsight" }}
	// Status is the status the Kuma resource.
    // +kubebuilder:validation:Optional
	Status   *apiextensionsv1.JSON {{ $tk }}json:"status,omitempty"{{ $tk }}
{{- else}}
	// Spec is the specification of the Kuma {{ .ProtoType }} resource.
    // +kubebuilder:validation:Optional
	Spec   *apiextensionsv1.JSON {{ $tk }}json:"spec,omitempty"{{ $tk }}
{{- end}}
}

// +kubebuilder:object:root=true
{{- if .ScopeNamespace }}
// +kubebuilder:resource:scope=Namespaced
{{- else }}
// +kubebuilder:resource:scope=Cluster
{{- end}}
type {{.ResourceType}}List struct {
	metav1.TypeMeta {{ $tk }}json:",inline"{{ $tk }}
	metav1.ListMeta {{ $tk }}json:"metadata,omitempty"{{ $tk }}
	Items           []{{.ResourceType}} {{ $tk }}json:"items"{{ $tk }}
}

{{- if not .SkipRegistration}}
func init() {
	SchemeBuilder.Register(&{{.ResourceType}}{}, &{{.ResourceType}}List{})
}
{{- end}}

func (cb *{{.ResourceType}}) GetObjectMeta() *metav1.ObjectMeta {
	return &cb.ObjectMeta
}

func (cb *{{.ResourceType}}) SetObjectMeta(m *metav1.ObjectMeta) {
	cb.ObjectMeta = *m
}

func (cb *{{.ResourceType}}) GetMesh() string {
	return cb.Mesh
}

func (cb *{{.ResourceType}}) SetMesh(mesh string) {
	cb.Mesh = mesh
}

func (cb *{{.ResourceType}}) GetSpec() (core_model.ResourceSpec, error) {
{{- if eq .ResourceType "DataplaneInsight" }}
	spec := cb.Status
{{- else}}
	spec := cb.Spec
{{- end}}
	m := {{$pkg}}.{{.ProtoType}}{}

    if spec == nil || len(spec.Raw) == 0 {
		return &m, nil
	}

	err := util_proto.FromJSON(spec.Raw, &m)
	return &m, err
}

func (cb *{{.ResourceType}}) SetSpec(spec core_model.ResourceSpec) {
	if spec == nil {
{{- if eq .ResourceType "DataplaneInsight" }}
		cb.Status = nil
{{- else }}
		cb.Spec = nil
{{- end }}
		return
	}

	s, ok := spec.(*{{$pkg}}.{{.ProtoType}}); 
	if !ok {
		panic(fmt.Sprintf("unexpected protobuf message type %T", spec))
	}

{{ if eq .ResourceType "DataplaneInsight" }}
	cb.Status = &apiextensionsv1.JSON{Raw: util_proto.MustMarshalJSON(s)}
{{- else}}
	cb.Spec = &apiextensionsv1.JSON{Raw: util_proto.MustMarshalJSON(s)}
{{- end}}
}

func (cb *{{.ResourceType}}) GetStatus() (core_model.ResourceStatus, error) {
	return nil, nil
}

func (cb *{{.ResourceType}}) SetStatus(_ core_model.ResourceStatus) error {
	return errors.New("status not supported")
}

func (cb *{{.ResourceType}}) Scope() model.Scope {
{{- if .ScopeNamespace }}
	return model.ScopeNamespace
{{- else }}
	return model.ScopeCluster
{{- end }}
}

func (l *{{.ResourceType}}List) GetItems() []model.KubernetesObject {
	result := make([]model.KubernetesObject, len(l.Items))
	for i := range l.Items {
		result[i] = &l.Items[i]
	}
	return result
}

{{if not .SkipRegistration}}
func init() {
	registry.RegisterObjectType(&{{ $pkg }}.{{.ProtoType}}{}, &{{.ResourceType}}{
		TypeMeta: metav1.TypeMeta{
			APIVersion: GroupVersion.String(),
			Kind:       "{{.ResourceType}}",
		},
	})
	registry.RegisterListType(&{{ $pkg }}.{{.ProtoType}}{}, &{{.ResourceType}}List{
		TypeMeta: metav1.TypeMeta{
			APIVersion: GroupVersion.String(),
			Kind:       "{{.ResourceType}}List",
		},
	})
}
{{- end }} {{/* .SkipRegistration */}}
{{- end }} {{/* .SkipKubernetesWrappers */}}
{{- end }} {{/* Resources */}}
`))

// ResourceTemplate for creating a Kuma resource.
var ResourceTemplate = template.Must(template.New("resource").Funcs(commontemplate.FuncMap).Parse(`
// Generated by tools/resource-gen. DO NOT EDIT.
// Run "make generate" to update this file.

{{ $pkg := printf "%s_proto" .Package }}

package {{.Package}}

import (
	"errors"
	"fmt"

	{{$pkg}} "github.com/kumahq/kuma/v2/api/{{.Package}}/v1alpha1"
	"github.com/kumahq/kuma/v2/pkg/core/resources/model"
	"github.com/kumahq/kuma/v2/pkg/core/resources/registry"
)

{{range .Resources}}
{{ $baseType := trimSuffix (trimSuffix .ResourceType "Overview") "Insight" }}
const (
	{{.ResourceType}}Type model.ResourceType = "{{.ResourceType}}"
)

var _ model.Resource = &{{.ResourceName}}{}

type {{.ResourceName}} struct {
	Meta model.ResourceMeta
	Spec *{{$pkg}}.{{.ProtoType}}
}

func New{{.ResourceName}}() *{{.ResourceName}} {
	return &{{.ResourceName}}{
		Spec: &{{$pkg}}.{{.ProtoType}}{},
	}
}

func (t *{{.ResourceName}}) GetMeta() model.ResourceMeta {
	return t.Meta
}

func (t *{{.ResourceName}}) SetMeta(m model.ResourceMeta) {
	t.Meta = m
}

func (t *{{.ResourceName}}) GetSpec() model.ResourceSpec {
	return t.Spec
}

{{with $in := .}}
{{range .Selectors}}
func (t *{{$in.ResourceName}}) {{.}}() []*{{$pkg}}.Selector {
	return t.Spec.Get{{.}}()
}
{{end}}
{{end}}

func (t *{{.ResourceName}}) SetSpec(spec model.ResourceSpec) error {
	protoType, ok := spec.(*{{$pkg}}.{{.ProtoType}})
	if !ok {
		return fmt.Errorf("invalid type %T for Spec", spec)
	} else {
		if protoType == nil {
			t.Spec = &{{$pkg}}.{{.ProtoType}}{}
		} else  {
			t.Spec = protoType
		}
		return nil
	}
}

func (t *{{.ResourceName}}) GetStatus() model.ResourceStatus {
	return nil
}

func (t *{{.ResourceName}}) SetStatus(_ model.ResourceStatus) error {
	return errors.New("status not supported")
}

func (t *{{.ResourceName}}) Descriptor() model.ResourceTypeDescriptor {
	return {{.ResourceName}}TypeDescriptor 
}
{{- if and (hasSuffix .ResourceType "Overview") (ne $baseType "Service") }}

func (t *{{.ResourceName}}) SetOverviewSpec(resource model.Resource, insight model.Resource) error {
	t.SetMeta(resource.GetMeta())
	overview := &{{$pkg}}.{{.ProtoType}}{
		{{$baseType}}: resource.GetSpec().(*{{$pkg}}.{{$baseType}}),
	}
	if insight != nil {
		ins, ok := insight.GetSpec().(*{{$pkg}}.{{$baseType}}Insight)
		if !ok {
			return errors.New("failed to convert to insight type '{{$baseType}}Insight'")
		}
		overview.{{$baseType}}Insight = ins
	}
	return t.SetSpec(overview)
}
{{- end }}

var _ model.ResourceList = &{{.ResourceName}}List{}

type {{.ResourceName}}List struct {
	Items      []*{{.ResourceName}}
	Pagination model.Pagination
}

func (l *{{.ResourceName}}List) GetItems() []model.Resource {
	res := make([]model.Resource, len(l.Items))
	for i, elem := range l.Items {
		res[i] = elem
	}
	return res
}

func (l *{{.ResourceName}}List) GetItemType() model.ResourceType {
	return {{.ResourceType}}Type
}

func (l *{{.ResourceName}}List) NewItem() model.Resource {
	return New{{.ResourceName}}()
}

func (l *{{.ResourceName}}List) AddItem(r model.Resource) error {
	if trr, ok := r.(*{{.ResourceName}}); ok {
		l.Items = append(l.Items, trr)
		return nil
	} else {
		return model.ErrorInvalidItemType((*{{.ResourceName}})(nil), r)
	}
}

func (l *{{.ResourceName}}List) GetPagination() *model.Pagination {
	return &l.Pagination
}

func (l *{{.ResourceName}}List) SetPagination(p model.Pagination) {
	l.Pagination = p
}

var {{.ResourceName}}TypeDescriptor = model.ResourceTypeDescriptor{
		Name: {{.ResourceType}}Type,
		Resource: New{{.ResourceName}}(),
		ResourceList: &{{.ResourceName}}List{},
		ReadOnly: {{.WsReadOnly}},
		AdminOnly: {{.WsAdminOnly}},
		Scope: {{if .Global}}model.ScopeGlobal{{else}}model.ScopeMesh{{end}},
		{{- if ne .KdsDirection ""}}
		KDSFlags: {{.KdsDirection}},
		{{- end}}
		{{- if .SkipKDSHash }}
		SkipKDSHash: true,
		{{- end}}
		WsPath: "{{.WsPath}}",
		{{- if ne .AlternativeWsPath "" }}
		AlternativeWsPath: "{{.AlternativeWsPath}}",
		{{- end }}
		KumactlArg: "{{.KumactlSingular}}",
		KumactlListArg: "{{.KumactlPlural}}",
		{{- if ne .KumactlSingularAlias ""}}
		KumactlArgAlias: "{{.KumactlSingularAlias}}",
		{{- end }}
		{{- if ne .KumactlPluralAlias ""}}
		KumactlListArgAlias: "{{.KumactlPluralAlias}}",
		{{- end }}
		AllowToInspect: {{.AllowToInspect}},
		IsPolicy: {{.IsPolicy}},
		SingularDisplayName: "{{.SingularDisplayName}}",
		PluralDisplayName: "{{.PluralDisplayName}}",
		{{- if ne .ShortName "" }}
		ShortName: "{{.ShortName}}",{{- end}}
		IsExperimental: {{.IsExperimental}},
        IsProxy: {{.IsProxy}},
{{- if .HasInsights}}
		Insight: New{{.ResourceType}}InsightResource(),
		Overview: New{{.ResourceType}}OverviewResource(),
{{- end}}
	}

{{- if not .SkipRegistration}}
func init() {
	registry.RegisterType({{.ResourceName}}TypeDescriptor)
}
{{- end}}
{{end}}
`))

var (
	readDir  = "."
	writeDir = "."
)

func Run() {
	var gen string
	var pkg string

	flag.StringVar(&gen, "generator", "", "the type of generator to run options: (type,crd,openapi)")
	flag.StringVar(&pkg, "package", "", "the name of the package to generate: (mesh, system)")
	flag.StringVar(&readDir, "readDir", "", "where to read files from, default: .")
	flag.StringVar(&writeDir, "writeDir", "", "where to write files to, default: .")

	flag.Parse()

	switch pkg {
	case "mesh", "system":
	default:
		log.Fatalf("package %s is not supported", pkg)
	}

	var types []protoreflect.MessageType
	protoregistry.GlobalTypes.RangeMessages(
		OnKumaResourceMessage(pkg, func(m protoreflect.MessageType) bool {
			types = append(types, m)
			return true
		}))

	// Sort by name so the output is deterministic.
	sort.Slice(types, func(i, j int) bool {
		return types[i].Descriptor().FullName() < types[j].Descriptor().FullName()
	})

	var resources []ResourceInfo
	for _, t := range types {
		resourceInfo := ToResourceInfo(t.Descriptor())
		resources = append(resources, resourceInfo)
	}

	var generatorFn GeneratorFn

	switch gen {
	case "type":
		generatorFn = TemplateGeneratorFn(ResourceTemplate)
	case "crd":
		generatorFn = TemplateGeneratorFn(CustomResourceTemplate)
	case "openapi":
		generatorFn = openApiGenerator
	default:
		log.Fatalf("%s is not a valid generator option\n", gen)
	}

	err := generatorFn(pkg, resources)
	if err != nil {
		log.Fatalf("%s\n", err)
	}
}

var AdditionalProtoTypes = []reflect.Type{
	reflect.TypeOf(v1alpha1.FileLoggingBackendConfig{}),
	reflect.TypeOf(v1alpha1.TcpLoggingBackendConfig{}),
	reflect.TypeOf(v1alpha1.ZipkinTracingBackendConfig{}),
	reflect.TypeOf(v1alpha1.DatadogTracingBackendConfig{}),
	reflect.TypeOf(v1alpha1.PrometheusMetricsBackendConfig{}),
	reflect.TypeOf(provided_config.ProvidedCertificateAuthorityConfig{}),
	reflect.TypeOf(builtin_config.BuiltinCertificateAuthorityConfig{}),
	reflect.TypeOf(v1alpha1.DataplaneOverview{}),
	reflect.TypeOf(system_proto.Zone{}),
}

func openApiGenerator(pkg string, resources []ResourceInfo) error {
	reflector := reflector{
		pkg:     pkg,
		typeSet: map[reflect.Type]struct{}{},
	}
	for _, r := range resources {
		tpe, exists := types.ProtoTypeToType[r.ResourceType]
		if !exists {
			continue
		}
		schemaMap := orderedmap.New[string, *jsonschema.Schema]()
		schemaMap.Set("type", &jsonschema.Schema{Type: "string"})
		schemaMap.Set("name", &jsonschema.Schema{Type: "string"})
		if !r.Global {
			schemaMap.Set("mesh", &jsonschema.Schema{Type: "string"})
		}
		schemaMap.Set("labels", &jsonschema.Schema{Type: "object", AdditionalProperties: &jsonschema.Schema{Type: "string"}})
		s, err := reflector.reflectFromType(tpe, true)
		if err != nil {
			return err
		}
		for pair := s.Properties.Oldest(); pair != nil; pair = pair.Next() {
			schemaMap.Set(pair.Key, pair.Value)
		}

		schema := jsonschema.Schema{
			Type:       "object",
			Required:   []string{"type", "name"},
			Properties: schemaMap,
		}

		if !r.Global {
			schema.Required = append(schema.Required, "mesh")
		}

		outDir := path.Join(writeDir, "api", pkg, "v1alpha1", strings.ToLower(r.ResourceType))

		// Ensure the directory exists
		if err := os.MkdirAll(outDir, 0o755); err != nil {
			return fmt.Errorf("failed to create directory: %w", err)
		}

		scope := "Mesh"
		if r.Global {
			scope = "Global"
		}

		// Generate rest.yaml from template to a temp file
		tmpRestFile, err := os.CreateTemp("", "rest-*.yaml")
		if err != nil {
			return fmt.Errorf("failed to create temp file: %w", err)
		}
		tmpRestPath := tmpRestFile.Name()
		tmpRestFile.Close()
		defer os.Remove(tmpRestPath)

		if err := commontemplate.PlainFileTemplate(
			path.Join(readDir, "tools", "openapi", "templates", "endpoints.yaml"),
			tmpRestPath,
			map[string]any{
				"Package":   "v1alpha1",
				"Name":      r.ResourceType,
				"ShortName": r.ShortName,
				"Scope":     scope,
				"Path":      r.WsPath,
			},
		); err != nil {
			return err
		}

		// Read the generated rest.yaml
		restContent, err := os.ReadFile(tmpRestPath)
		if err != nil {
			return fmt.Errorf("failed to read temp rest.yaml: %w", err)
		}

		// Parse the rest.yaml
		var restSpec map[string]interface{}
		if err := yaml.Unmarshal(restContent, &restSpec); err != nil {
			return fmt.Errorf("failed to unmarshal rest.yaml: %w", err)
		}

		// Inject the schema into components.schemas
		components, ok := restSpec["components"].(map[string]interface{})
		if !ok {
			components = make(map[string]interface{})
			restSpec["components"] = components
		}
		schemas, ok := components["schemas"].(map[string]interface{})
		if !ok {
			schemas = make(map[string]interface{})
			components["schemas"] = schemas
		}

		// Convert the schema to a map
		schemaBytes, err := yaml.Marshal(schema)
		if err != nil {
			return err
		}
		var schemaItemMap map[string]interface{}
		if err := yaml.Unmarshal(schemaBytes, &schemaItemMap); err != nil {
			return err
		}

		schemas[r.ResourceType+"Item"] = schemaItemMap

		// Write the merged rest.yaml
		mergedContent, err := yaml.Marshal(restSpec)
		if err != nil {
			return fmt.Errorf("failed to marshal merged rest.yaml: %w", err)
		}

		if err := os.WriteFile(path.Join(outDir, "rest.yaml"), mergedContent, 0o600); err != nil {
			return err
		}
	}

	if pkg == "mesh" {
		for _, tpe := range AdditionalProtoTypes {
			s, err := reflector.reflectFromType(tpe, true)
			if err != nil {
				return err
			}
			if err := writeSchemaToFile(s, tpe.Name(), getReference(tpe, pkg)); err != nil {
				return err
			}
		}
	}

	return nil
}

type reference struct {
	dir       string
	file      string
	ref       string
	refPrefix string
}

func (r reference) OutDir() string {
	return r.dir
}

func (r reference) Path() string {
	return path.Join(r.dir, r.file)
}

func (r reference) FullRef() string {
	return path.Join(r.refPrefix, r.file) + r.ref
}

func getReference(r reflect.Type, pkg string) reference {
	return reference{
		dir:       path.Join(writeDir, "api", pkg, "v1alpha1", strings.ToLower(r.Name())),
		file:      "schema.yaml",
		ref:       "#/components/schemas/" + r.Name(),
		refPrefix: "/specs/protoresources/" + strings.ToLower(r.Name()),
	}
}

func writeSchemaToFile(schema *jsonschema.Schema, schemaName string, ref reference) error {
	wrapped := map[string]any{
		"openapi": "3.1.0",
		"info": map[string]string{
			"x-ref-schema-name": schemaName,
		},
		"components": map[string]any{
			"schemas": map[string]*jsonschema.Schema{
				schemaName: schema,
			},
		},
	}

	out, err := yaml.Marshal(wrapped)
	if err != nil {
		return err
	}

	// Ensure the directory exists
	if err := os.MkdirAll(ref.OutDir(), 0o755); err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	if err := os.WriteFile(ref.Path(), out, 0o600); err != nil {
		return err
	}

	return nil
}

type reflector struct {
	typeSet map[reflect.Type]struct{}
	pkg     string
}

func (r *reflector) reflectFromType(t reflect.Type, withBackendCheck bool) (*jsonschema.Schema, error) {
	rflctr := &jsonschema.Reflector{
		DoNotReference:            true,
		AllowAdditionalProperties: true,
		IgnoredTypes:              []any{structpb.Struct{}},
		KeyNamer: func(key string) string {
			if key == "RSAbits" {
				return "rsaBits"
			}
			return lowerFirst(snakeToCamel(key))
		},
		Mapper: func(t reflect.Type) *jsonschema.Schema {
			s, err := r.mapper(t, withBackendCheck)
			if err != nil {
				fmt.Printf("error occurred during mapping: %v\n", err)
				return nil
			}
			return s
		},
	}

	// Workaround: AddGoComments requires the correct module path to load Go source
	// comments for OpenAPI schema descriptions. Without this, field descriptions
	// are lost during schema generation.
	modulePath := "github.com/kumahq/kuma/v2"

	// AddGoComments uses Go's package loading which requires the path to be relative
	// to the current working directory. For downstream projects using symlinks,
	// we need to temporarily change to the resolved directory.
	originalDir, err := os.Getwd()
	if err != nil {
		return nil, fmt.Errorf("failed to get working directory: %w", err)
	}

	// Resolve symlinks in readDir to get actual module path
	resolvedReadDir, err := filepath.EvalSymlinks(readDir)
	if err != nil {
		resolvedReadDir = readDir
	}

	// Convert to absolute path
	absReadDir, err := filepath.Abs(resolvedReadDir)
	if err != nil {
		return nil, fmt.Errorf("failed to get absolute path: %w", err)
	}

	// Change to module root directory only for AddGoComments
	// Must restore before ReflectFromType to avoid path issues in recursive calls
	if err := os.Chdir(absReadDir); err != nil {
		return nil, fmt.Errorf("failed to change directory to %s: %w", absReadDir, err)
	}
	err = rflctr.AddGoComments(modulePath, "api/")
	_ = os.Chdir(originalDir)
	if err != nil {
		return nil, err
	}

	s := rflctr.ReflectFromType(t)
	return &jsonschema.Schema{
		Type:        "object",
		Properties:  s.Properties,
		OneOf:       s.OneOf,
		Extras:      s.Extras,
		Description: s.Description,
	}, nil
}

func lowerFirst(s string) string {
	if s == "" {
		return s
	}
	r, size := utf8.DecodeRuneInString(s)
	return string(unicode.ToLower(r)) + s[size:]
}

func (r *reflector) mapper(t reflect.Type, withBackendCheck bool) (*jsonschema.Schema, error) {
	if hasOneofField(t) {
		return r.handleOneOf(t)
	}

	backendConf := BackendToOneOfs[t.Name()]
	if !withBackendCheck || backendConf == nil {
		return valueMapper(t), nil
	}

	schema, err := r.reflectFromType(t, false)
	if err != nil {
		return nil, err
	}
	schema.ID = ""
	schema.Version = ""
	schema.Properties.Set("conf", &jsonschema.Schema{
		Type:  "object",
		OneOf: backendConf,
	})
	return schema, nil
}

func (r reflector) handleOneOf(t reflect.Type) (*jsonschema.Schema, error) {
	s := &jsonschema.Schema{}
	for i := range t.NumField() {
		fd := t.Field(i)
		_, ok := fd.Tag.Lookup("protobuf_oneof")
		if !ok {
			// skip proto specific fields like 'state', 'unknownFields', 'sizeCache'
			continue
		}
		types, err := OneofWrapperTypes(t, fd)
		if err != nil {
			return nil, err
		}

		keys := maps.SortedKeys(types)
		mapping := map[string]string{}
		for _, discriminator := range keys {
			t := types[discriminator]
			ref := getReference(t, r.pkg)
			s.OneOf = append(s.OneOf, &jsonschema.Schema{
				Ref: ref.FullRef(),
			})
			mapping[discriminator] = ref.FullRef()
			if _, ok := r.typeSet[t]; ok {
				continue
			}
			r.typeSet[t] = struct{}{}
			schema, err := r.reflectFromType(t, true)
			if err != nil {
				return nil, err
			}
			if err := writeSchemaToFile(schema, t.Name(), getReference(t, r.pkg)); err != nil {
				return nil, err
			}
		}
	}

	return s, nil
}

type GeneratorFn func(pkg string, resources []ResourceInfo) error

func TemplateGeneratorFn(tmpl *template.Template) GeneratorFn {
	return func(pkg string, resources []ResourceInfo) error {
		outBuf := bytes.Buffer{}
		if err := tmpl.Execute(&outBuf, struct {
			Package   string
			Resources []ResourceInfo
		}{
			Package:   pkg,
			Resources: resources,
		}); err != nil {
			return err
		}

		out, err := format.Source(outBuf.Bytes())
		if err != nil {
			return err
		}
		if _, err := os.Stdout.Write(out); err != nil {
			return err
		}
		return nil
	}
}

var BackendToOneOfs = map[string][]*jsonschema.Schema{
	"CertificateAuthorityBackend": {
		{Ref: "/specs/protoresources/providedcertificateauthorityconfig/schema.yaml#/components/schemas/ProvidedCertificateAuthorityConfig"},
		{Ref: "/specs/protoresources/builtincertificateauthorityconfig/schema.yaml#/components/schemas/BuiltinCertificateAuthorityConfig"},
	},
	"LoggingBackend": {
		{Ref: "/specs/protoresources/fileloggingbackendconfig/schema.yaml#/components/schemas/FileLoggingBackendConfig"},
		{Ref: "/specs/protoresources/tcploggingbackendconfig/schema.yaml#/components/schemas/TcpLoggingBackendConfig"},
	},
	"TracingBackend": {
		{Ref: "/specs/protoresources/datadogtracingbackendconfig/schema.yaml#/components/schemas/DatadogTracingBackendConfig"},
		{Ref: "/specs/protoresources/zipkintracingbackendconfig/schema.yaml#/components/schemas/ZipkinTracingBackendConfig"},
	},
	"MetricsBackend": {
		{Ref: "/specs/protoresources/prometheusmetricsbackendconfig/schema.yaml#/components/schemas/PrometheusMetricsBackendConfig"},
	},
}

func valueMapper(r reflect.Type) *jsonschema.Schema {
	switch r {
	case reflect.TypeOf(wrapperspb.DoubleValue{}), reflect.TypeOf(wrapperspb.FloatValue{}):
		return &jsonschema.Schema{
			Type: "number",
		}
	case reflect.TypeOf(wrapperspb.Int64Value{}):
		return &jsonschema.Schema{
			Type:   "integer",
			Format: "int64",
		}
	case reflect.TypeOf(wrapperspb.UInt64Value{}):
		return &jsonschema.Schema{
			Type:   "integer",
			Format: "uint64",
		}
	case reflect.TypeOf(wrapperspb.Int32Value{}):
		return &jsonschema.Schema{
			Type:   "integer",
			Format: "int32",
		}
	case reflect.TypeOf(wrapperspb.UInt32Value{}):
		return &jsonschema.Schema{
			Type:   "integer",
			Format: "uint32",
		}
	case reflect.TypeOf(wrapperspb.BoolValue{}):
		return &jsonschema.Schema{
			Type: "boolean",
		}
	case reflect.TypeOf(wrapperspb.StringValue{}):
		return &jsonschema.Schema{
			Type: "string",
		}
	case reflect.TypeOf(wrapperspb.BytesValue{}):
		return &jsonschema.Schema{
			Type:   "string",
			Format: "byte",
		}
	default:
		return nil
	}
}

func hasOneofField(r reflect.Type) bool {
	md, ok := protoDescFromType(r)
	if !ok {
		return false
	}
	return md.Oneofs().Len() > 0
}

func snakeToCamel(s string) string {
	parts := strings.Split(s, "_")
	if len(parts) == 1 {
		return s
	}

	camel := strings.ToLower(parts[0])
	caser := cases.Title(language.Und)

	for _, part := range parts[1:] {
		if part == "" {
			continue
		}
		camel += caser.String(strings.ToLower(part))
	}

	return camel
}
