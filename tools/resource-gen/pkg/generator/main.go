package generator

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"log"
	"os"
	"path"
	"reflect"
	"sort"
	"strings"
	"text/template"

	"github.com/invopop/jsonschema"
	orderedmap "github.com/wk8/go-ordered-map/v2"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/reflect/protoregistry"
	"google.golang.org/protobuf/types/known/structpb"
	"google.golang.org/protobuf/types/known/wrapperspb"
	"sigs.k8s.io/yaml"

	"github.com/kumahq/kuma/api/mesh/v1alpha1"
	system_proto "github.com/kumahq/kuma/api/system/v1alpha1"
	builtin_config "github.com/kumahq/kuma/pkg/plugins/ca/builtin/config"
	provided_config "github.com/kumahq/kuma/pkg/plugins/ca/provided/config"
	"github.com/kumahq/kuma/tools/policy-gen/generator/pkg/save"
	. "github.com/kumahq/kuma/tools/resource-gen/genutils"
)

// CustomResourceTemplate for creating a Kubernetes CRD to wrap a Kuma resource.
var CustomResourceTemplate = template.Must(template.New("custom-resource").Parse(`
// Generated by tools/resource-gen. DO NOT EDIT.
// Run "make generate" to update this file.

{{ $pkg := printf "%s_proto" .Package }}
{{ $tk := "` + "`" + `" }}

package v1alpha1

import (
	"errors"
	"fmt"

	apiextensionsv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	{{ $pkg }} "github.com/kumahq/kuma/api/{{ .Package }}/v1alpha1"
	core_model "github.com/kumahq/kuma/pkg/core/resources/model"
	"github.com/kumahq/kuma/pkg/plugins/resources/k8s/native/pkg/model"
	"github.com/kumahq/kuma/pkg/plugins/resources/k8s/native/pkg/registry"
	util_proto "github.com/kumahq/kuma/pkg/util/proto"
)

{{range .Resources}}
{{- if not .SkipKubernetesWrappers }}

// +kubebuilder:object:root=true
{{- if .ScopeNamespace }}
// +kubebuilder:resource:categories=kuma,scope=Namespaced{{- if ne .ShortName ""}},shortName={{.ShortName}}{{- end}}
{{- else }}
// +kubebuilder:resource:categories=kuma,scope=Cluster{{- if ne .ShortName ""}},shortName={{.ShortName}}{{- end}}
{{- end}}
{{- range .AdditionalPrinterColumns }}
// +kubebuilder:printcolumn:{{ . }}
{{- end}}
type {{.ResourceType}} struct {
	metav1.TypeMeta   {{ $tk }}json:",inline"{{ $tk }}
	metav1.ObjectMeta {{ $tk }}json:"metadata,omitempty"{{ $tk }}

    // Mesh is the name of the Kuma mesh this resource belongs to.
	// It may be omitted for cluster-scoped resources.
	//
    // +kubebuilder:validation:Optional
	Mesh string {{ $tk }}json:"mesh,omitempty"{{ $tk }}

{{- if eq .ResourceType "DataplaneInsight" }}
	// Status is the status the Kuma resource.
    // +kubebuilder:validation:Optional
	Status   *apiextensionsv1.JSON {{ $tk }}json:"status,omitempty"{{ $tk }}
{{- else}}
	// Spec is the specification of the Kuma {{ .ProtoType }} resource.
    // +kubebuilder:validation:Optional
	Spec   *apiextensionsv1.JSON {{ $tk }}json:"spec,omitempty"{{ $tk }}
{{- end}}
}

// +kubebuilder:object:root=true
{{- if .ScopeNamespace }}
// +kubebuilder:resource:scope=Namespaced
{{- else }}
// +kubebuilder:resource:scope=Cluster
{{- end}}
type {{.ResourceType}}List struct {
	metav1.TypeMeta {{ $tk }}json:",inline"{{ $tk }}
	metav1.ListMeta {{ $tk }}json:"metadata,omitempty"{{ $tk }}
	Items           []{{.ResourceType}} {{ $tk }}json:"items"{{ $tk }}
}

{{- if not .SkipRegistration}}
func init() {
	SchemeBuilder.Register(&{{.ResourceType}}{}, &{{.ResourceType}}List{})
}
{{- end}}

func (cb *{{.ResourceType}}) GetObjectMeta() *metav1.ObjectMeta {
	return &cb.ObjectMeta
}

func (cb *{{.ResourceType}}) SetObjectMeta(m *metav1.ObjectMeta) {
	cb.ObjectMeta = *m
}

func (cb *{{.ResourceType}}) GetMesh() string {
	return cb.Mesh
}

func (cb *{{.ResourceType}}) SetMesh(mesh string) {
	cb.Mesh = mesh
}

func (cb *{{.ResourceType}}) GetSpec() (core_model.ResourceSpec, error) {
{{- if eq .ResourceType "DataplaneInsight" }}
	spec := cb.Status
{{- else}}
	spec := cb.Spec
{{- end}}
	m := {{$pkg}}.{{.ProtoType}}{}

    if spec == nil || len(spec.Raw) == 0 {
		return &m, nil
	}

	err := util_proto.FromJSON(spec.Raw, &m)
	return &m, err
}

func (cb *{{.ResourceType}}) SetSpec(spec core_model.ResourceSpec) {
	if spec == nil {
{{- if eq .ResourceType "DataplaneInsight" }}
		cb.Status = nil
{{- else }}
		cb.Spec = nil
{{- end }}
		return
	}

	s, ok := spec.(*{{$pkg}}.{{.ProtoType}}); 
	if !ok {
		panic(fmt.Sprintf("unexpected protobuf message type %T", spec))
	}

{{ if eq .ResourceType "DataplaneInsight" }}
	cb.Status = &apiextensionsv1.JSON{Raw: util_proto.MustMarshalJSON(s)}
{{- else}}
	cb.Spec = &apiextensionsv1.JSON{Raw: util_proto.MustMarshalJSON(s)}
{{- end}}
}

func (cb *{{.ResourceType}}) GetStatus() (core_model.ResourceStatus, error) {
	return nil, nil
}

func (cb *{{.ResourceType}}) SetStatus(_ core_model.ResourceStatus) error {
	return errors.New("status not supported")
}

func (cb *{{.ResourceType}}) Scope() model.Scope {
{{- if .ScopeNamespace }}
	return model.ScopeNamespace
{{- else }}
	return model.ScopeCluster
{{- end }}
}

func (l *{{.ResourceType}}List) GetItems() []model.KubernetesObject {
	result := make([]model.KubernetesObject, len(l.Items))
	for i := range l.Items {
		result[i] = &l.Items[i]
	}
	return result
}

{{if not .SkipRegistration}}
func init() {
	registry.RegisterObjectType(&{{ $pkg }}.{{.ProtoType}}{}, &{{.ResourceType}}{
		TypeMeta: metav1.TypeMeta{
			APIVersion: GroupVersion.String(),
			Kind:       "{{.ResourceType}}",
		},
	})
	registry.RegisterListType(&{{ $pkg }}.{{.ProtoType}}{}, &{{.ResourceType}}List{
		TypeMeta: metav1.TypeMeta{
			APIVersion: GroupVersion.String(),
			Kind:       "{{.ResourceType}}List",
		},
	})
}
{{- end }} {{/* .SkipRegistration */}}
{{- end }} {{/* .SkipKubernetesWrappers */}}
{{- end }} {{/* Resources */}}
`))

// ResourceTemplate for creating a Kuma resource.
var ResourceTemplate = template.Must(template.New("resource").Funcs(map[string]any{"hasSuffix": strings.HasSuffix, "trimSuffix": strings.TrimSuffix}).Parse(`
// Generated by tools/resource-gen. DO NOT EDIT.
// Run "make generate" to update this file.

{{ $pkg := printf "%s_proto" .Package }}

package {{.Package}}

import (
	"errors"
	"fmt"

	{{$pkg}} "github.com/kumahq/kuma/api/{{.Package}}/v1alpha1"
	"github.com/kumahq/kuma/pkg/core/resources/model"
	"github.com/kumahq/kuma/pkg/core/resources/registry"
)

{{range .Resources}}
{{ $baseType := trimSuffix (trimSuffix .ResourceType "Overview") "Insight" }}
const (
	{{.ResourceType}}Type model.ResourceType = "{{.ResourceType}}"
)

var _ model.Resource = &{{.ResourceName}}{}

type {{.ResourceName}} struct {
	Meta model.ResourceMeta
	Spec *{{$pkg}}.{{.ProtoType}}
}

func New{{.ResourceName}}() *{{.ResourceName}} {
	return &{{.ResourceName}}{
		Spec: &{{$pkg}}.{{.ProtoType}}{},
	}
}

func (t *{{.ResourceName}}) GetMeta() model.ResourceMeta {
	return t.Meta
}

func (t *{{.ResourceName}}) SetMeta(m model.ResourceMeta) {
	t.Meta = m
}

func (t *{{.ResourceName}}) GetSpec() model.ResourceSpec {
	return t.Spec
}

{{with $in := .}}
{{range .Selectors}}
func (t *{{$in.ResourceName}}) {{.}}() []*{{$pkg}}.Selector {
	return t.Spec.Get{{.}}()
}
{{end}}
{{end}}

func (t *{{.ResourceName}}) SetSpec(spec model.ResourceSpec) error {
	protoType, ok := spec.(*{{$pkg}}.{{.ProtoType}})
	if !ok {
		return fmt.Errorf("invalid type %T for Spec", spec)
	} else {
		if protoType == nil {
			t.Spec = &{{$pkg}}.{{.ProtoType}}{}
		} else  {
			t.Spec = protoType
		}
		return nil
	}
}

func (t *{{.ResourceName}}) GetStatus() model.ResourceStatus {
	return nil
}

func (t *{{.ResourceName}}) SetStatus(_ model.ResourceStatus) error {
	return errors.New("status not supported")
}

func (t *{{.ResourceName}}) Descriptor() model.ResourceTypeDescriptor {
	return {{.ResourceName}}TypeDescriptor 
}
{{- if and (hasSuffix .ResourceType "Overview") (ne $baseType "Service") }}

func (t *{{.ResourceName}}) SetOverviewSpec(resource model.Resource, insight model.Resource) error {
	t.SetMeta(resource.GetMeta())
	overview := &{{$pkg}}.{{.ProtoType}}{
		{{$baseType}}: resource.GetSpec().(*{{$pkg}}.{{$baseType}}),
	}
	if insight != nil {
		ins, ok := insight.GetSpec().(*{{$pkg}}.{{$baseType}}Insight)
		if !ok {
			return errors.New("failed to convert to insight type '{{$baseType}}Insight'")
		}
		overview.{{$baseType}}Insight = ins
	}
	return t.SetSpec(overview)
}
{{- end }}

var _ model.ResourceList = &{{.ResourceName}}List{}

type {{.ResourceName}}List struct {
	Items      []*{{.ResourceName}}
	Pagination model.Pagination
}

func (l *{{.ResourceName}}List) GetItems() []model.Resource {
	res := make([]model.Resource, len(l.Items))
	for i, elem := range l.Items {
		res[i] = elem
	}
	return res
}

func (l *{{.ResourceName}}List) GetItemType() model.ResourceType {
	return {{.ResourceType}}Type
}

func (l *{{.ResourceName}}List) NewItem() model.Resource {
	return New{{.ResourceName}}()
}

func (l *{{.ResourceName}}List) AddItem(r model.Resource) error {
	if trr, ok := r.(*{{.ResourceName}}); ok {
		l.Items = append(l.Items, trr)
		return nil
	} else {
		return model.ErrorInvalidItemType((*{{.ResourceName}})(nil), r)
	}
}

func (l *{{.ResourceName}}List) GetPagination() *model.Pagination {
	return &l.Pagination
}

func (l *{{.ResourceName}}List) SetPagination(p model.Pagination) {
	l.Pagination = p
}

var {{.ResourceName}}TypeDescriptor = model.ResourceTypeDescriptor{
		Name: {{.ResourceType}}Type,
		Resource: New{{.ResourceName}}(),
		ResourceList: &{{.ResourceName}}List{},
		ReadOnly: {{.WsReadOnly}},
		AdminOnly: {{.WsAdminOnly}},
		Scope: {{if .Global}}model.ScopeGlobal{{else}}model.ScopeMesh{{end}},
		{{- if ne .KdsDirection ""}}
		KDSFlags: {{.KdsDirection}},
		{{- end}}
		{{- if .SkipKDSHash }}
		SkipKDSHash: true,
		{{- end}}
		WsPath: "{{.WsPath}}",
		{{- if ne .AlternativeWsPath "" }}
		AlternativeWsPath: "{{.AlternativeWsPath}}",
		{{- end }}
		KumactlArg: "{{.KumactlSingular}}",
		KumactlListArg: "{{.KumactlPlural}}",
		{{- if ne .KumactlSingularAlias ""}}
		KumactlArgAlias: "{{.KumactlSingularAlias}}",
		{{- end }}
		{{- if ne .KumactlPluralAlias ""}}
		KumactlListArgAlias: "{{.KumactlPluralAlias}}",
		{{- end }}
		AllowToInspect: {{.AllowToInspect}},
		IsPolicy: {{.IsPolicy}},
		SingularDisplayName: "{{.SingularDisplayName}}",
		PluralDisplayName: "{{.PluralDisplayName}}",
		{{- if ne .ShortName "" }}
		ShortName: "{{.ShortName}}",{{- end}}
		IsExperimental: {{.IsExperimental}},
        IsProxy: {{.IsProxy}},
{{- if .HasInsights}}
		Insight: New{{.ResourceType}}InsightResource(),
		Overview: New{{.ResourceType}}OverviewResource(),
{{- end}}
	}

{{- if not .SkipRegistration}}
func init() {
	registry.RegisterType({{.ResourceName}}TypeDescriptor)
}
{{- end}}
{{end}}
`))

var (
	readDir  = "."
	writeDir = "."
)

func Run() {
	var gen string
	var pkg string

	flag.StringVar(&gen, "generator", "", "the type of generator to run options: (type,crd,openapi)")
	flag.StringVar(&pkg, "package", "", "the name of the package to generate: (mesh, system)")
	flag.StringVar(&readDir, "readDir", "", "where to read files from, default: .")
	flag.StringVar(&writeDir, "writeDir", "", "where to write files to, default: .")

	flag.Parse()

	switch pkg {
	case "mesh", "system":
	default:
		log.Fatalf("package %s is not supported", pkg)
	}

	var types []protoreflect.MessageType
	protoregistry.GlobalTypes.RangeMessages(
		OnKumaResourceMessage(pkg, func(m protoreflect.MessageType) bool {
			types = append(types, m)
			return true
		}))

	// Sort by name so the output is deterministic.
	sort.Slice(types, func(i, j int) bool {
		return types[i].Descriptor().FullName() < types[j].Descriptor().FullName()
	})

	var resources []ResourceInfo
	for _, t := range types {
		resourceInfo := ToResourceInfo(t.Descriptor())
		resources = append(resources, resourceInfo)
	}

	var generatorFn GeneratorFn

	switch gen {
	case "type":
		generatorFn = TemplateGeneratorFn(ResourceTemplate)
	case "crd":
		generatorFn = TemplateGeneratorFn(CustomResourceTemplate)
	case "openapi":
		generatorFn = openApiGenerator
	default:
		log.Fatalf("%s is not a valid generator option\n", gen)
	}

	err := generatorFn(pkg, resources)
	if err != nil {
		log.Fatalf("%s\n", err)
	}
}

var AdditionalProtoTypes = []reflect.Type{
	reflect.TypeOf(v1alpha1.FileLoggingBackendConfig{}),
	reflect.TypeOf(v1alpha1.TcpLoggingBackendConfig{}),
	reflect.TypeOf(v1alpha1.ZipkinTracingBackendConfig{}),
	reflect.TypeOf(v1alpha1.DatadogTracingBackendConfig{}),
	reflect.TypeOf(v1alpha1.PrometheusMetricsBackendConfig{}),
	reflect.TypeOf(provided_config.ProvidedCertificateAuthorityConfig{}),
	reflect.TypeOf(builtin_config.BuiltinCertificateAuthorityConfig{}),
	reflect.TypeOf(v1alpha1.DataplaneOverview{}),
	reflect.TypeOf(system_proto.Zone{}),
	// reflect.TypeOf(system_proto.DataSource_File{}),
	// reflect.TypeOf(system_proto.DataSource_Inline{}),
	// reflect.TypeOf(system_proto.DataSource_InlineString{}),
	// reflect.TypeOf(system_proto.DataSource_Secret{}),
}

var ProtoTypeToType = map[string]reflect.Type{
	"Mesh":        reflect.TypeOf(v1alpha1.Mesh{}),
	"Dataplane":   reflect.TypeOf(v1alpha1.Dataplane{}),
	"MeshGateway": reflect.TypeOf(v1alpha1.MeshGateway{}),
}

func openApiGenerator(pkg string, resources []ResourceInfo) error {
	// // this is where the new types need to be added if we want to generate openAPI for it
	// reflector := jsonschema.Reflector{
	// 	ExpandedStruct:            true,
	// 	DoNotReference:            true,
	// 	AllowAdditionalProperties: true,
	// 	IgnoredTypes:              []any{structpb.Struct{}},
	// 	KeyNamer: func(key string) string {
	// 		if key == "RSAbits" {
	// 			return "rsaBits"
	// 		}
	// 		return snakeToCamel(key)
	// 	},
	// }
	// err := reflector.AddGoComments("github.com/kumahq/kuma/", path.Join(readDir, "api/"))
	// if err != nil {
	// 	return err
	// }
	// typeSet := map[reflect.Type]struct{}{}
	//
	// mapper1 := &mapper{
	// 	pkg:       pkg,
	// 	reflector: reflector,
	// 	typeSet:   typeSet,
	// }
	// reflector.Mapper = mapper1.Map

	reflector := reflector{
		pkg:     pkg,
		typeSet: map[reflect.Type]struct{}{},
	}
	for _, r := range resources {
		tpe, exists := ProtoTypeToType[r.ResourceType]
		if !exists {
			continue
		}
		schemaMap := orderedmap.New[string, *jsonschema.Schema]()
		schemaMap.Set("type", &jsonschema.Schema{Type: "string"})
		schemaMap.Set("name", &jsonschema.Schema{Type: "string"})
		if !r.Global {
			schemaMap.Set("mesh", &jsonschema.Schema{Type: "string"})
		}
		schemaMap.Set("labels", &jsonschema.Schema{Type: "object", AdditionalProperties: &jsonschema.Schema{Type: "string"}})
		s, err := reflector.reflectFromType(tpe, true, false, true, "")
		if err != nil {
			return err
		}
		for pair := s.Properties.Oldest(); pair != nil; pair = pair.Next() {
			schemaMap.Set(pair.Key, pair.Value)
		}

		schema := jsonschema.Schema{
			Type:       "object",
			Required:   []string{"type", "name"},
			Properties: schemaMap,
		}

		if !r.Global {
			schema.Required = append(schema.Required, "mesh")
		}

		out, err := yaml.Marshal(schema)
		if err != nil {
			return err
		}

		outDir := path.Join(writeDir, "api", pkg, "v1alpha1", strings.ToLower(r.ResourceType))

		// Ensure the directory exists
		err = os.MkdirAll(outDir, 0o755)
		if err != nil {
			return fmt.Errorf("failed to create directory: %w", err)
		}

		err = os.WriteFile(path.Join(outDir, "schema.yaml"), out, 0o600)
		if err != nil {
			return err
		}

		templatePath := path.Join(readDir, "tools", "openapi", "templates", "endpoints.yaml")
		tmpl, err := template.ParseFiles(templatePath)
		if err != nil {
			return err
		}
		scope := "Mesh"
		if r.Global {
			scope = "Global"
		}
		opts := map[string]any{
			"Package":   "v1alpha1",
			"Name":      r.ResourceType,
			"ShortName": r.ShortName,
			"Scope":     scope,
			"Path":      r.WsPath,
		}
		err = save.PlainTemplate(tmpl, opts, path.Join(outDir, "rest.yaml"))
		if err != nil {
			return err
		}
	}

	for _, tpe := range AdditionalProtoTypes {
		s, err := reflector.reflectFromType(tpe, false, false, true, "")
		if err != nil {
			return err
		}
		if err := writeSchemaToFile(s, tpe.Name(), getReference(tpe, pkg)); err != nil {
			return err
		}
	}

	return nil
}

type reference struct {
	dir       string
	file      string
	ref       string
	refPrefix string
}

func (r reference) OutDir() string {
	return r.dir
}

func (r reference) Path() string {
	return path.Join(r.dir, r.file)
}

func (r reference) FullRef() string {
	return path.Join(r.refPrefix, r.file) + r.ref
}

func getReference(r reflect.Type, pkg string) reference {
	return reference{
		dir:       path.Join(writeDir, "api", pkg, "v1alpha1", strings.ToLower(r.Name())),
		file:      "schema.yaml",
		ref:       "#/components/schemas/" + r.Name(),
		refPrefix: "/specs/protoresources/" + strings.ToLower(r.Name()),
	}
}

func writeSchemaToFile(schema *jsonschema.Schema, schemaName string, ref reference) error {
	wrapped := map[string]any{
		"openapi": "3.1.0",
		"info": map[string]string{
			"x-ref-schema-name": schemaName,
		},
		"components": map[string]any{
			"schemas": map[string]*jsonschema.Schema{
				schemaName: schema,
			},
		},
	}

	out, err := yaml.Marshal(wrapped)
	if err != nil {
		return err
	}

	// Ensure the directory exists
	if err = os.MkdirAll(ref.OutDir(), 0o755); err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	if err = os.WriteFile(ref.Path(), out, 0o600); err != nil {
		return err
	}

	return nil
}

type reflector struct {
	typeSet map[reflect.Type]struct{}
	pkg     string
}

func (r *reflector) reflectFromType(t reflect.Type, expandedStruct, oneOfSubtype, withBackendCheck bool, name string) (*jsonschema.Schema, error) {
	reflector := jsonschema.Reflector{
		ExpandedStruct:            expandedStruct,
		DoNotReference:            true,
		AllowAdditionalProperties: true,
		IgnoredTypes:              []any{structpb.Struct{}},
		KeyNamer: func(key string) string {
			if key == "RSAbits" {
				return "rsaBits"
			}
			return snakeToCamel(key)
		},
		Mapper: func(t reflect.Type) *jsonschema.Schema {
			s, err := r.mapper(t, withBackendCheck)
			if err != nil {
				// log
				return nil
			}
			return s
		},
	}
	if !withBackendCheck {
		reflector.Mapper = nil
	}
	if err := reflector.AddGoComments("github.com/kumahq/kuma/", path.Join(readDir, "api/")); err != nil {
		return nil, err
	}

	s := reflector.ReflectFromType(t)
	if oneOfSubtype {
		s.Properties.Set("type", &jsonschema.Schema{Type: "string", Const: name})
	}
	return &jsonschema.Schema{
		Type:       "object",
		Properties: s.Properties,
		OneOf:      s.OneOf,
		Extras:     s.Extras,
	}, nil
}

func (r *reflector) mapper(t reflect.Type, withBackendCheck bool) (*jsonschema.Schema, error) {
	if !hasOneofField(t) && withBackendCheck {
		if backendConf := BackendToOneOfs[t.Name()]; backendConf != nil {
			schema, err := r.reflectFromType(t, false, false, false, "")
			if err != nil {
				return nil, err
			}
			schema.ID = ""
			schema.Version = ""
			schema.Properties.Set("conf", &jsonschema.Schema{
				Type:  "object",
				OneOf: backendConf,
			})
			return schema, nil
		}
		return valueMapper(t), nil
	}

	s := &jsonschema.Schema{}
	for i := range t.NumField() {
		fd := t.Field(i)
		_, ok := fd.Tag.Lookup("protobuf_oneof")
		if !ok {
			// skip proto specific fields like 'state', 'unknownFields', 'sizeCache'
			continue
		}
		types, err := OneofWrapperTypes(t, fd)
		if err != nil {
			return nil, err
		}

		mapping := map[string]string{}
		for discriminator, t := range types {
			ref := getReference(t, r.pkg)
			s.OneOf = append(s.OneOf, &jsonschema.Schema{
				Ref: ref.FullRef(),
			})
			mapping[discriminator] = ref.FullRef()
			if _, ok := r.typeSet[t]; ok {
				continue
			}
			r.typeSet[t] = struct{}{}
			schema, err := r.reflectFromType(t, false, true, true, discriminator)
			if err != nil {
				return nil, err
			}
			if err := writeSchemaToFile(schema, t.Name(), getReference(t, r.pkg)); err != nil {
				return nil, err
			}
		}
		s.Extras = map[string]any{
			"discriminator": map[string]any{
				"propertyName": "type",
				"mapping":      mapping,
			},
		}
	}

	return s, nil
}

// func generateSchemaToFile(r reflect.Type, pkg string, typeSet map[reflect.Type]struct{}) error {
// 	reflector := jsonschema.Reflector{
// 		ExpandedStruct:            false,
// 		DoNotReference:            true,
// 		AllowAdditionalProperties: true,
// 		IgnoredTypes:              []any{structpb.Struct{}},
// 		KeyNamer: func(key string) string {
// 			if key == "RSAbits" {
// 				return "rsaBits"
// 			}
// 			return snakeToCamel(key)
// 		},
// 		// Mapper: (&mapper{pkg: pkg, }).Map,
// 	}
//
// 	if err := reflector.AddGoComments("github.com/kumahq/kuma/", path.Join(readDir, "api/")); err != nil {
// 		return err
// 	}
// 	mapper := &mapper{
// 		pkg:       pkg,
// 		reflector: reflector,
// 		typeSet:   typeSet,
// 	}
// 	reflector.Mapper = mapper.Map
// 	properties := reflector.ReflectFromType(r).Properties
//
// 	schema := &jsonschema.Schema{
// 		Type:       "object",
// 		Properties: properties,
// 	}
//
// 	return writeSchemaToFile(schema, r.Name(), getReference(r, pkg))
// }

type GeneratorFn func(pkg string, resources []ResourceInfo) error

func TemplateGeneratorFn(tmpl *template.Template) GeneratorFn {
	return func(pkg string, resources []ResourceInfo) error {
		outBuf := bytes.Buffer{}
		if err := tmpl.Execute(&outBuf, struct {
			Package   string
			Resources []ResourceInfo
		}{
			Package:   pkg,
			Resources: resources,
		}); err != nil {
			return err
		}

		out, err := format.Source(outBuf.Bytes())
		if err != nil {
			return err
		}
		if _, err := os.Stdout.Write(out); err != nil {
			return err
		}
		return nil
	}
}

var BackendToOneOfs = map[string][]*jsonschema.Schema{
	"CertificateAuthorityBackend": {
		{Ref: "/specs/protoresources/providedcertificateauthorityconfig/schema.yaml#/components/schemas/ProvidedCertificateAuthorityConfig"},
		{Ref: "/specs/protoresources/builtincertificateauthorityconfig/schema.yaml#/components/schemas/BuiltinCertificateAuthorityConfig"},
	},
	"LoggingBackend": {
		{Ref: "/specs/protoresources/fileloggingbackendconfig/schema.yaml#/components/schemas/FileLoggingBackendConfig"},
		{Ref: "/specs/protoresources/tcploggingbackendconfig/schema.yaml#/components/schemas/TcpLoggingBackendConfig"},
	},
	"TracingBackend": {
		{Ref: "/specs/protoresources/datadogtracingbackendconfig/schema.yaml#/components/schemas/DatadogTracingBackendConfig"},
		{Ref: "/specs/protoresources/zipkintracingbackendconfig/schema.yaml#/components/schemas/ZipkinTracingBackendConfig"},
	},
	"MetricsBackend": {
		{Ref: "/specs/protoresources/prometheusmetricsbackendconfig/schema.yaml#/components/schemas/PrometheusMetricsBackendConfig"},
	},
}

// func typeMapperFactory(self jsonschema.Reflector, typeSet map[reflect.Type]struct{}) func(r reflect.Type) *jsonschema.Schema {
// 	f := func(r reflect.Type) *jsonschema.Schema {
// 		schema, done := confMapper(r, self, typeSet)
// 		if done {
// 			return schema
// 		}
//
// 		return valueMapper(r)
// 	}
//
// 	self.Mapper = valueMapper
//
// 	return f
// }
//
// func typeMapperFactory2(self jsonschema.Reflector, typeSet map[reflect.Type]struct{}) func(r reflect.Type) *jsonschema.Schema {
// 	f := func(r reflect.Type) *jsonschema.Schema {
// 		schema, done := confMapper2(r, self, typeSet)
// 		if done {
// 			return schema
// 		}
//
// 		return valueMapper(r)
// 	}
//
// 	self.Mapper = valueMapper
//
// 	return f
// }

func valueMapper(r reflect.Type) *jsonschema.Schema {
	switch r {
	case reflect.TypeOf(wrapperspb.DoubleValue{}), reflect.TypeOf(wrapperspb.FloatValue{}):
		return &jsonschema.Schema{
			Type: "number",
		}
	case reflect.TypeOf(wrapperspb.Int64Value{}):
		return &jsonschema.Schema{
			Type:   "integer",
			Format: "int64",
		}
	case reflect.TypeOf(wrapperspb.UInt64Value{}):
		return &jsonschema.Schema{
			Type:   "integer",
			Format: "uint64",
		}
	case reflect.TypeOf(wrapperspb.Int32Value{}):
		return &jsonschema.Schema{
			Type:   "integer",
			Format: "int32",
		}
	case reflect.TypeOf(wrapperspb.UInt32Value{}):
		return &jsonschema.Schema{
			Type:   "integer",
			Format: "uint32",
		}
	case reflect.TypeOf(wrapperspb.BoolValue{}):
		return &jsonschema.Schema{
			Type: "boolean",
		}
	case reflect.TypeOf(wrapperspb.StringValue{}):
		return &jsonschema.Schema{
			Type: "string",
		}
	case reflect.TypeOf(wrapperspb.BytesValue{}):
		return &jsonschema.Schema{
			Type:   "string",
			Format: "byte",
		}
	default:
		return nil
	}
}

// // Ensure we have the pointer type that implements proto.Message.
// // Returns the message descriptor if t is a generated protobuf message.
// func ProtoDescFromType(t reflect.Type) (protoreflect.MessageDescriptor, bool) {
// 	// Unwrap pointers until a non-pointer (generated messages are structs).
// 	for t.Kind() == reflect.Pointer {
// 		t = t.Elem()
// 	}
// 	if t.Kind() != reflect.Struct {
// 		return nil, false
// 	}
// 	// The pointer to the struct implements proto.Message.
// 	pt := reflect.PointerTo(t)
// 	msg, ok := reflect.Zero(pt).Interface().(proto.Message)
// 	if !ok {
// 		return nil, false
// 	}
// 	return msg.ProtoReflect().Descriptor(), true
// }

func hasOneofField(r reflect.Type) bool {
	md, ok := protoDescFromType(r)
	if !ok {
		return false
	}
	return md.Oneofs().Len() > 0
}

// type mapper struct {
// 	pkg       string
// 	typeSet   map[reflect.Type]struct{}
// 	reflector *reflector
// }
//
// func (m *mapper) Map(r reflect.Type) *jsonschema.Schema {
// 	if !hasOneofField(r) {
// 		if backendConf := BackendToOneOfs[r.Name()]; backendConf != nil {
// 			schema := m.reflector.reflectFromType(r, true, false)
// 			schema.ID = ""
// 			schema.Version = ""
// 			schema.Properties.Set("conf", &jsonschema.Schema{
// 				Type:  "object",
// 				OneOf: backendConf,
// 			})
// 			return schema
// 		}
// 		return valueMapper(r)
// 	}
//
// 	s := &jsonschema.Schema{}
// 	for i := range r.NumField() {
// 		fd := r.Field(i)
// 		_, ok := fd.Tag.Lookup("protobuf_oneof")
// 		if !ok {
// 			// skip proto specific fields like 'state', 'unknownFields', 'sizeCache'
// 			continue
// 		}
// 		types, err := OneofWrapperTypes(r, fd)
// 		if err != nil {
// 			fmt.Println("ERROR", err)
// 			return nil
// 		}
//
// 		mapping := map[string]string{}
// 		for discriminator, t := range types {
// 			fmt.Println("DEBUG", discriminator, t.String())
// 			ref := getReference(t, m.pkg)
// 			s.OneOf = append(s.OneOf, &jsonschema.Schema{
// 				Ref: ref.FullRef(),
// 			})
// 			mapping[discriminator] = ref.FullRef()
// 			if _, ok := m.typeSet[t]; ok {
// 				continue
// 			}
// 			m.typeSet[t] = struct{}{}
// 			if err := generateSchemaToFile(t, m.pkg, m.typeSet); err != nil {
// 				fmt.Println("ERROR", err)
// 				return nil
// 			}
// 		}
// 		s.Extras = map[string]any{
// 			"discriminator": map[string]any{
// 				"propertyName": "type",
// 				"mapping":      mapping,
// 			},
// 		}
// 	}
//
// 	return s
// }

// func confMapper(r reflect.Type, self jsonschema.Reflector, typeSet map[reflect.Type]struct{}) (*jsonschema.Schema, bool) {
// 	if !hasOneofField(r) {
// 		if backendConf := BackendToOneOfs[r.Name()]; backendConf != nil {
// 			schema := self.ReflectFromType(r)
// 			schema.ID = ""
// 			schema.Version = ""
// 			schema.Properties.Set("conf", &jsonschema.Schema{
// 				Type:  "object",
// 				OneOf: backendConf,
// 			})
// 			return schema, true
// 		}
// 		return nil, false
// 	}
//
// 	s := &jsonschema.Schema{}
// 	// for i := range r.NumField() {
// 	// 	fd := r.Field(i)
// 	// 	_, ok := fd.Tag.Lookup("protobuf_oneof")
// 	// 	if !ok {
// 	// 		// skip proto specific fields like 'state', 'unknownFields', 'sizeCache'
// 	// 		continue
// 	// 	}
// 	// 	types, err := OneofWrapperTypes(r, fd)
// 	// 	if err != nil {
// 	// 		fmt.Println("ERROR", err)
// 	// 		return nil, false
// 	// 	}
// 	// 	for _, t := range types {
// 	// 		ref := getReference(r, m.pkg)
// 	// 		s.OneOf = append(s.OneOf, &jsonschema.Schema{
// 	// 			Ref: "/specs/protoresources/" + strings.ToLower(name) + "/schema.yaml#/components/schemas/" + name,
// 	// 		})
// 	// 		typeSet[t.Elem()] = struct{}{}
// 	// 	}
// 	// }
//
// 	// types, err := OneofWrapperTypesV2(r, "type")
// 	// if err != nil {
// 	// 	fmt.Println("ERROR", err)
// 	// 	return nil, false
// 	// }
// 	// for _, t := range types {
// 	// 	typeSet[t] = struct{}{}
// 	// }
// 	//
// 	// s := &jsonschema.Schema{}
// 	// for i := range md.Fields().Len() {
// 	// 	fd := md.Fields().Get(i)
// 	// 	fd.
// 	// 		od := fd.ContainingOneof()
// 	// 	if od == nil {
// 	// 		fmt.Println("DEBUG", "is it even the case?")
// 	// 	}
// 	// 	for j := range od.Fields().Len() {
// 	// 		odField := od.Fields().Get(j)
// 	// 		s.OneOf = append(s.OneOf, &jsonschema.Schema{Ref: string(odField.FullName())})
// 	// 		fmt.Println("DEBUG", ReflectTypeFromFD(odField).Kind())
// 	// 	}
// 	// }
// 	return s, true
// 	// oneofs := pdesc.Oneofs()
// 	//
// 	// if oneofs.Len() > 0 {
// 	// }
// 	//
// 	// for i := range oneofs.Len() {
// 	// 	od := oneofs.Get(i)
// 	// 	for j := range od.Fields().Len() {
// 	// 		odField := od.Fields().Get(j)
// 	// 		odField.ContainingOneof()
// 	// 		fmt.Println("DEBUG", odField.FullName())
// 	// 		desc := ReflectTypeFromFD(odField)
// 	// 		self.ReflectFromType(desc)
// 	// 	}
// 	// }
//
// 	// od := pdesc.Oneofs().ByName("type")
// 	// if od != nil {
// 	// 	for i := range od.Fields().Len() {
// 	// 		if od.Fields().Get(i).Kind() == protoreflect.MessageKind {
// 	// 			msg := od.Fields().Get(i).Message()
// 	// 			fmt.Println("DEBUG", od.Fields().Get(i).Name())
// 	// 			fmt.Println("DEBUG", msg.FullName())
// 	// 		}
// 	// 	}
// 	// }
// 	// if r.Kind() == reflect.Struct {
// 	// 	for i := range r.NumField() {
// 	// 		f := r.Field(i)
// 	// 		if oneofName, ok := f.Tag.Lookup("protobuf_oneof"); ok {
// 	// 			fmt.Println("Field", f.Name, "is a oneof:", oneofName, r.Name())
// 	// 		}
// 	// 	}
// 	// }
// 	// backendConf := BackendToOneOfs[r.Name()]
// 	// if backendConf != nil {
// 	// 	schema := self.ReflectFromType(r)
// 	// 	schema.ID = ""
// 	// 	schema.Version = ""
// 	// 	schema.Properties.Set("conf", &jsonschema.Schema{
// 	// 		Type:  "object",
// 	// 		OneOf: backendConf,
// 	// 	})
// 	// 	return schema, true
// 	// }
// 	// if r.Name() == "DataSource" {
// 	// 	return &jsonschema.Schema{
// 	// 		OneOf: []*jsonschema.Schema{
// 	// 			{Ref: "/specs/protoresources/datasource_file/schema.yaml#/components/schemas/DataSource_File"},
// 	// 			{Ref: "/specs/protoresources/datasource_file/schema.yaml#/components/schemas/DataSource_Inline"},
// 	// 			{Ref: "/specs/protoresources/datasource_file/schema.yaml#/components/schemas/DataSource_InlineString"},
// 	// 			{Ref: "/specs/protoresources/datasource_file/schema.yaml#/components/schemas/DataSource_Secret"},
// 	// 		},
// 	// 		Extras: map[string]any{
// 	// 			"discriminator": map[string]any{
// 	// 				"propertyName": "type",
// 	// 				"mapping": map[string]any{
// 	// 					"file":         "/specs/protoresources/datasource_file/schema.yaml#/components/schemas/DataSource_File",
// 	// 					"inline":       "/specs/protoresources/datasource_file/schema.yaml#/components/schemas/DataSource_Inline",
// 	// 					"inlineString": "/specs/protoresources/datasource_file/schema.yaml#/components/schemas/DataSource_InlineString",
// 	// 					"secret":       "/specs/protoresources/datasource_file/schema.yaml#/components/schemas/DataSource_Secret",
// 	// 				},
// 	// 			},
// 	// 		},
// 	// 	}, true
// 	// }
// 	return nil, false
// }

// snakeToCamel converts a snake_case string to camelCase
// func confMapper2(r reflect.Type, self jsonschema.Reflector, typeSet map[reflect.Type]struct{}) (*jsonschema.Schema, bool) {
// 	if s, ok := confMapper(r, self, typeSet); ok {
// 		return s, ok
// 	}
// 	if strings.HasPrefix(r.Name(), "DataSource_") {
// 		schema := self.ReflectFromType(r)
// 		parts := strings.Split(r.Name(), "_")
// 		schema.Properties.Set("type", &jsonschema.Schema{Type: "string", Const: strings.ToLower(parts[1])})
// 		return schema, true
// 	}
// 	return nil, false
// }

func snakeToCamel(s string) string {
	parts := strings.Split(s, "_")
	if len(parts) == 1 {
		return s
	}

	camel := strings.ToLower(parts[0])
	caser := cases.Title(language.Und)

	for _, part := range parts[1:] {
		if part == "" {
			continue
		}
		camel += caser.String(strings.ToLower(part))
	}

	return camel
}
