// Package types provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package types

// Defines values for ResourceTypeDescriptionScope.
const (
	Global ResourceTypeDescriptionScope = "Global"
	Mesh   ResourceTypeDescriptionScope = "Mesh"
)

// DataplaneInbound defines model for DataplaneInbound.
type DataplaneInbound struct {
	Kri      string `json:"kri"`
	Port     int    `json:"port"`
	Protocol string `json:"protocol"`
}

// DataplaneOutbound defines model for DataplaneOutbound.
type DataplaneOutbound struct {
	Kri      string `json:"kri"`
	Port     int    `json:"port"`
	Protocol string `json:"protocol"`
}

// FromRule defines model for FromRule.
type FromRule struct {
	Inbound Inbound `json:"inbound"`
	Rules   []Rule  `json:"rules"`
}

// HttpMatch defines model for HttpMatch.
type HttpMatch struct {
	Hash  string      `json:"hash"`
	Match interface{} `json:"match"`
}

// Inbound defines model for Inbound.
type Inbound struct {
	Name *string           `json:"name,omitempty"`
	Port int               `json:"port"`
	Tags map[string]string `json:"tags"`
}

// InboundPoliciesList defines model for InboundPoliciesList.
type InboundPoliciesList struct {
	// Policies The final computed configuration, derived by merging all policies whose 'targetRef' field matches the proxy. The merging process follows [RFC 7396 (JSON Merge Patch)](https://datatracker.ietf.org/doc/html/rfc7396), with the order of merging influenced by factors such as where the policy was applied (e.g., custom namespace, system, or global control plane), policy role, and targetRef specificity.
	Policies []InboundPolicyConf `json:"policies"`
}

// InboundPolicyConf defines model for InboundPolicyConf.
type InboundPolicyConf struct {
	Kind string `json:"kind"`

	// Origins The list of policies KRI that contributed to the 'conf'. The order is important as it reflects in what order confs were merged to get the resulting 'conf'.
	Origins []PolicyOrigin `json:"origins"`
	Rules   []PolicyRule   `json:"rules"`
}

// InboundRule defines model for InboundRule.
type InboundRule struct {
	// Conf The final computed configuration for the data plane proxy, derived by merging all policies whose 'targetRef' field matches the proxy. The merging process follows [RFC 7396 (JSON Merge Patch)](https://datatracker.ietf.org/doc/html/rfc7396), with the order of merging influenced by factors such as where the policy was applied (e.g., custom namespace, system, or global control plane), policy role, and targetRef specificity.
	Conf []interface{} `json:"conf"`

	// Origin The list of policies that contributed to the 'conf'. The order is important as it reflects in what order confs were merged to get the resulting 'conf'.
	Origin []ResourceRuleOrigin `json:"origin"`
}

// InboundRulesEntry defines model for InboundRulesEntry.
type InboundRulesEntry struct {
	Inbound Inbound `json:"inbound"`

	// Rules The 'rules' field is an array to allow for future expansion when 'matches' conditions are added. Currently, it contains a single item.
	Rules []InboundRule `json:"rules"`
}

// InspectRule defines model for InspectRule.
type InspectRule struct {
	// FromRules a set of rules for each inbound of this proxy
	FromRules *[]FromRule `json:"fromRules,omitempty"`

	// InboundRules a set of rules for each inbound port of the proxy. When the policy descriptor has 'isFromAsRules' set to true, this field supersedes 'fromRules' and should be used instead.
	InboundRules *[]InboundRulesEntry `json:"inboundRules,omitempty"`

	// ProxyRule a rule that affects the entire proxy
	ProxyRule *ProxyRule `json:"proxyRule,omitempty"`

	// ToResourceRules a set of rules for the outbounds produced by real resources (i.e MeshService, MeshExternalService, MeshMultiZoneService).
	ToResourceRules *[]ResourceRule `json:"toResourceRules,omitempty"`

	// ToRules a set of rules for the outbounds of this proxy. The field is not set when 'meshService.mode' on Mesh is set to 'Exclusive'.
	ToRules *[]Rule `json:"toRules,omitempty"`

	// Type the type of the policy
	Type string `json:"type"`

	// Warnings a set of warnings to show in policy matching
	Warnings *[]string `json:"warnings,omitempty"`
}

// Meta defines model for Meta.
type Meta struct {
	// Labels the label of the resource
	Labels map[string]string `json:"labels"`

	// Mesh the mesh this resource is part of
	Mesh string `json:"mesh"`

	// Name the name of the resource
	Name string `json:"name"`

	// Type the type of this resource
	Type string `json:"type"`
}

// PoliciesList defines model for PoliciesList.
type PoliciesList struct {
	// Policies The final computed configuration, derived by merging all policies whose 'targetRef' field matches the proxy. The merging process follows [RFC 7396 (JSON Merge Patch)](https://datatracker.ietf.org/doc/html/rfc7396), with the order of merging influenced by factors such as where the policy was applied (e.g., custom namespace, system, or global control plane), policy role, and targetRef specificity.
	Policies []PolicyConf `json:"policies"`
}

// PolicyConf defines model for PolicyConf.
type PolicyConf struct {
	// Conf The final computed configuration for the data plane proxy, derived by merging all policies whose 'targetRef' field matches the proxy. The merging process follows [RFC 7396 (JSON Merge Patch)](https://datatracker.ietf.org/doc/html/rfc7396), with the order of merging influenced by factors such as where the policy was applied (e.g., custom namespace, system, or global control plane), policy role, and targetRef specificity.
	Conf interface{} `json:"conf"`
	Kind string      `json:"kind"`

	// Origins The list of policies KRI that contributed to the 'conf'. The order is important as it reflects in what order confs were merged to get the resulting 'conf'.
	Origins []PolicyOrigin `json:"origins"`
}

// PolicyDescription information about a policy
type PolicyDescription struct {
	// HasFromTargetRef indicates that this policy can be used as an inbound policy
	HasFromTargetRef bool `json:"hasFromTargetRef"`

	// HasToTargetRef indicates that this policy can be used as an outbound policy
	HasToTargetRef bool `json:"hasToTargetRef"`

	// IsFromAsRules If set to `true`, performs a backward compatibility conversion from the deprecated 'from' array to the new 'rules' array. This ensures older policies remain functional under the updated schema.
	IsFromAsRules bool `json:"isFromAsRules"`

	// IsTargetRef whether this policy uses targetRef matching
	IsTargetRef bool `json:"isTargetRef"`
}

// PolicyOrigin The list of policies KRI that contributed to the 'conf'. The order is important as it reflects in what order confs were merged to get the resulting 'conf'.
type PolicyOrigin struct {
	Kri string `json:"kri"`
}

// PolicyRule defines model for PolicyRule.
type PolicyRule struct {
	// Conf The final computed configuration for the data plane proxy, derived by merging all policies whose 'targetRef' field matches the proxy. The merging process follows [RFC 7396 (JSON Merge Patch)](https://datatracker.ietf.org/doc/html/rfc7396), with the order of merging influenced by factors such as where the policy was applied (e.g., custom namespace, system, or global control plane), policy role, and targetRef specificity.
	Conf interface{} `json:"conf"`
}

// ProxyRule a rule that affects the entire proxy
type ProxyRule struct {
	// Conf The actual conf generated
	Conf   interface{} `json:"conf"`
	Origin []Meta      `json:"origin"`
}

// ResourceRule defines model for ResourceRule.
type ResourceRule struct {
	// Conf The actual conf generated
	Conf []interface{} `json:"conf"`

	// Origin The list of policies that contributed to the 'conf'. The order is important as it reflects in what order confs were merged to get the resulting 'conf'.
	Origin              []ResourceRuleOrigin `json:"origin"`
	ResourceMeta        Meta                 `json:"resourceMeta"`
	ResourceSectionName *string              `json:"resourceSectionName,omitempty"`
}

// ResourceRuleOrigin defines model for ResourceRuleOrigin.
type ResourceRuleOrigin struct {
	ResourceMeta *Meta `json:"resourceMeta,omitempty"`

	// RuleIndex index of the to-item in the policy
	RuleIndex *int `json:"ruleIndex,omitempty"`
}

// ResourceTypeDescription Description of a resource type, this is useful for dynamically generated clients and the gui
type ResourceTypeDescription struct {
	// IncludeInFederation description resources of this type should be included in federetion-with-policies export profile (especially useful for moving from non-federated to federated or migrating to a new global).
	IncludeInFederation bool `json:"includeInFederation"`

	// Name the name of the resource type
	Name string `json:"name"`

	// Path the path to use for accessing this resource. If scope is `Global` then it will be `/<path>` otherwise it will be `/meshes/<path>`
	Path              string `json:"path"`
	PluralDisplayName string `json:"pluralDisplayName"`

	// Policy information about a policy
	Policy              *PolicyDescription           `json:"policy,omitempty"`
	ReadOnly            bool                         `json:"readOnly"`
	Scope               ResourceTypeDescriptionScope `json:"scope"`
	SingularDisplayName string                       `json:"singularDisplayName"`
}

// ResourceTypeDescriptionScope defines model for ResourceTypeDescription.Scope.
type ResourceTypeDescriptionScope string

// RouteConf defines model for RouteConf.
type RouteConf struct {
	Kind string `json:"kind"`

	// Origins The list of policies KRI that contributed to the 'conf'. The order is important as it reflects in what order confs were merged to get the resulting 'conf'.
	Origins []PolicyOrigin `json:"origins"`

	// Rules Computed list of routing rules
	Rules []RouteRules `json:"rules"`
}

// RouteRules defines model for RouteRules.
type RouteRules struct {
	// Conf The final computed configuration for the data plane proxy, derived by merging all policies whose 'targetRef' field matches the proxy. The merging process follows [RFC 7396 (JSON Merge Patch)](https://datatracker.ietf.org/doc/html/rfc7396), with the order of merging influenced by factors such as where the policy was applied (e.g., custom namespace, system, or global control plane), policy role, and targetRef specificity.
	Conf interface{} `json:"conf"`
	Kri  string      `json:"kri"`

	// Matches List of matches for which this rule will apply
	Matches []interface{} `json:"matches"`
}

// RoutesList defines model for RoutesList.
type RoutesList struct {
	// Routes Computed list of routes
	Routes []RouteConf `json:"routes"`
}

// Rule defines model for Rule.
type Rule struct {
	// Conf The actual conf generated
	Conf     interface{}   `json:"conf"`
	Matchers []RuleMatcher `json:"matchers"`
	Origin   []Meta        `json:"origin"`
}

// RuleMatcher A matcher to select which traffic this conf applies to
type RuleMatcher struct {
	// Key the key to match against
	Key string `json:"key"`

	// Not whether we check on the absence of this key:value pair
	Not bool `json:"not"`

	// Value the value for the key to match against
	Value string `json:"value"`
}
