.PHONY: help clean clean/build clean/proto \
		dev/tools \
		dev/install/protoc dev/install/protoc-gen-gogofast dev/install/protoc-gen-validate \
		dev/install/ginkgo \
		dev/install/kubebuilder dev/install/kustomize \
		dev/install/kubectl dev/install/kind dev/install/minikube \
		start/k8s start/kind start/control-plane/k8s \
		deploy/example-app/k8s deploy/control-plane/k8s \
		kind/load/control-plane kind/load/konvoy-dp kind/load/konvoy-injector \
		generate protoc/pkg/config/app/konvoyctl/v1alpha1 generate/konvoyctl/install/control-plane \
		fmt fmt/go fmt/proto vet check test integration build run/k8s run/universal/memory run/universal/postgres \
		images image/konvoy-cp image/konvoy-dp image/konvoyctl image/konvoy-injector \
		build/konvoy-cp build/konvoy-dp build/konvoyctl build/konvoy-injector \
		docs docs/konvoyctl \
		curl/listeners curl/clusters \
		run/example/envoy config_dump/example/envoy \
        run/example/docker-compose wait/example/docker-compose curl/example/docker-compose stats/example/docker-compose \
        verify/example/docker-compose/inbound verify/example/docker-compose/outbound verify/example/docker-compose \
		build/example/minikube deploy/example/minikube wait/example/minikube curl/example/minikube stats/example/minikube \
        verify/example/minikube/inbound verify/example/minikube/outbound verify/example/minikube \
		print/kubebuilder/test_assets \
		generate/test/cert/konvoy-injector run/konvoy-injector \
		run/konvoy-dp

PKG_LIST := ./... ./api/... ./pkg/plugins/resources/k8s/native/...

BUILD_DIR ?= build
BUILD_ARTIFACTS_DIR ?= $(BUILD_DIR)/artifacts

GO_TEST_OPTS ?=

BUILD_COVERAGE_DIR ?= $(BUILD_DIR)/coverage

COVERAGE_PROFILE := $(BUILD_COVERAGE_DIR)/coverage.out
COVERAGE_REPORT_HTML := $(BUILD_COVERAGE_DIR)/coverage.html

COVERAGE_INTEGRATION_PROFILE := $(BUILD_COVERAGE_DIR)/coverage-integration.out
COVERAGE_INTEGRATION_REPORT_HTML := $(BUILD_COVERAGE_DIR)/coverage-integration.html

CP_BIND_HOST ?= localhost
CP_GRPC_PORT ?= 5678
CP_HTTP_PORT ?= 5679

LOCAL_IP ?= $(shell ifconfig en0 | grep 'inet ' | awk '{print $$2}')

ENVOY_BINARY ?= envoy
EXAMPLE_ENVOY_ID ?= example
EXAMPLE_ENVOY_CLUSTER ?= demo
EXAMPLE_ENVOY_IP ?= $(LOCAL_IP)
EXAMPLE_ENVOY_PORT ?= 8080
ENVOY_ADMIN_PORT ?= 9901

EXAMPLE_NAMESPACE ?= konvoy-demo

KIND_KUBECONFIG = $(shell kind get kubeconfig-path --name=konvoy)

define KIND_EXAMPLE_ENVOY_ID
$(shell KUBECONFIG=$(KIND_KUBECONFIG) kubectl -n $(EXAMPLE_NAMESPACE) exec $$(kubectl -n $(EXAMPLE_NAMESPACE) get pods -l app=demo-app -o=jsonpath='{.items[0].metadata.name}') -c konvoy-sidecar printenv KONVOY_DATAPLANE_ID)
endef

SIMPLE_DISCOVERY_REQUEST ?= '{"node": {"id": "$(EXAMPLE_ENVOY_ID)", "metadata": {"IPS": "$(EXAMPLE_ENVOY_IP)", "PORTS": "$(EXAMPLE_ENVOY_PORT)"}}}'

KONVOY_VERSION ?= master

BINTRAY_REGISTRY ?= kong-docker-konvoy-docker.bintray.io
BINTRAY_USERNAME ?=
BINTRAY_API_KEY ?=

KONVOY_CP_DOCKER_IMAGE ?= konvoy/konvoy-control-plane:latest
KONVOY_DP_DOCKER_IMAGE ?= konvoy/konvoy-dataplane:latest
KONVOYCTL_DOCKER_IMAGE ?= konvoy/konvoyctl:latest
KONVOY_INJECTOR_DOCKER_IMAGE ?= konvoy/konvoy-injector:latest

PROTOC_VERSION := 3.6.1
PROTOC_PGV_VERSION := v0.1.0
GOGO_PROTOBUF_VERSION := v1.2.1

CI_KUBEBUILDER_VERSION ?= 2.0.0-alpha.4
CI_KIND_VERSION ?= v0.3.0
CI_MINIKUBE_VERSION ?= v1.1.0
CI_KUBECTL_VERSION ?= v1.14.0
CI_TOOLS_IMAGE ?= circleci/golang:1.12

CI_TOOLS_DIR ?= $(HOME)/bin
GOPATH_DIR := $(shell go env GOPATH | awk -F: '{print $$1}')
GOPATH_BIN_DIR := $(GOPATH_DIR)/bin
BUILD_KONVOYCTL_DIR := ${BUILD_ARTIFACTS_DIR}/konvoyctl
export PATH := $(BUILD_KONVOYCTL_DIR):$(CI_TOOLS_DIR):$(GOPATH_BIN_DIR):$(PATH)

PROTOC_PATH := $(CI_TOOLS_DIR)/protoc
KUBEBUILDER_DIR := $(CI_TOOLS_DIR)/kubebuilder.d
KUBEBUILDER_PATH := $(CI_TOOLS_DIR)/kubebuilder
KUSTOMIZE_PATH := $(CI_TOOLS_DIR)/kustomize
KIND_PATH := $(CI_TOOLS_DIR)/kind
MINIKUBE_PATH := $(CI_TOOLS_DIR)/minikube
KUBECTL_PATH := $(CI_TOOLS_DIR)/kubectl
KUBE_APISERVER_PATH := $(CI_TOOLS_DIR)/kube-apiserver
ETCD_PATH := $(CI_TOOLS_DIR)/etcd

PROTO_DIR := ./pkg/config

protoc_search_go_packages := \
	github.com/gogo/protobuf@$(GOGO_PROTOBUF_VERSION)/protobuf \
	github.com/envoyproxy/protoc-gen-validate@$(PROTOC_PGV_VERSION) \

protoc_search_go_paths := $(foreach go_package,$(protoc_search_go_packages),--proto_path=$(GOPATH_DIR)/pkg/mod/$(go_package))

# Protobuf-specifc configuration
PROTOC_GO := protoc \
	--proto_path=. \
	$(protoc_search_go_paths) \
	--gogofast_out=plugins=grpc:. \
	--validate_out=lang=gogo:.

PROTOC_OS=unknown
PROTOC_ARCH=$(shell uname -m)

UNAME_S := $(shell uname -s)
ifeq ($(UNAME_S), Linux)
	PROTOC_OS=linux
else
	ifeq ($(UNAME_S), Darwin)
		PROTOC_OS=osx
	endif
endif

# tools we expect to be pre-installed
CLANG_FORMAT_PATH ?= clang-format

export TEST_ASSET_KUBE_APISERVER=$(KUBE_APISERVER_PATH)
export TEST_ASSET_ETCD=$(ETCD_PATH)
export TEST_ASSET_KUBECTL=$(KUBECTL_PATH)

DOCKER_COMPOSE_OPTIONS ?=

GOOS := $(shell go env GOOS)
GOARCH := $(shell go env GOARCH)

help: ## Display this help screen
	@grep -h -E '^[a-zA-Z0-9_/-]+:.*?## .*$$' $(MAKEFILE_LIST) | awk 'BEGIN {FS = ":.*?## "}; {printf "\033[36m%-30s\033[0m %s\n", $$1, $$2}'

dev/tools: dev/install/protoc dev/install/protoc-gen-gogofast dev/install/protoc-gen-validate \
           dev/install/ginkgo \
		   dev/install/kubebuilder dev/install/kustomize \
		   dev/install/kubectl dev/install/kind dev/install/minikube ## Bootstrap: Install all development tools

dev/install/protoc: ## Bootstrap: Install Protoc (protobuf compiler)
	@if [ -e $(PROTOC_PATH) ]; then echo "Protoc $$( $(PROTOC_PATH) --version ) is already installed at $(PROTOC_PATH)" ; fi
	@if [ ! -e $(PROTOC_PATH) ]; then \
		echo "Installing Protoc $(PROTOC_VERSION) ..." \
		&& set -x \
		&& curl -Lo /tmp/protoc-$(PROTOC_VERSION)-$(PROTOC_OS)-$(PROTOC_ARCH).zip https://github.com/protocolbuffers/protobuf/releases/download/v$(PROTOC_VERSION)/protoc-$(PROTOC_VERSION)-$(PROTOC_OS)-$(PROTOC_ARCH).zip \
		&& unzip /tmp/protoc-$(PROTOC_VERSION)-$(PROTOC_OS)-$(PROTOC_ARCH).zip bin/protoc -d /tmp/protoc-$(PROTOC_VERSION)-$(PROTOC_OS)-$(PROTOC_ARCH) \
		&& mkdir -p $(CI_TOOLS_DIR) \
		&& cp /tmp/protoc-$(PROTOC_VERSION)-$(PROTOC_OS)-$(PROTOC_ARCH)/bin/protoc $(PROTOC_PATH) \
		&& rm -rf /tmp/protoc-$(PROTOC_VERSION)-$(PROTOC_OS)-$(PROTOC_ARCH) \
		&& rm /tmp/protoc-$(PROTOC_VERSION)-$(PROTOC_OS)-$(PROTOC_ARCH).zip \
		&& set +x \
		&& echo "Protoc $(PROTOC_VERSION) has been installed at $(PROTOC_PATH)" ; fi

dev/install/protoc-gen-gogofast: ## Bootstrap: Install Protoc Go Plugin (protobuf Go generator)
	go get -u github.com/gogo/protobuf/protoc-gen-gogofast@$(GOGO_PROTOBUF_VERSION)

dev/install/protoc-gen-validate: ## Bootstrap: Install Protoc Gen Validate Plugin (protobuf validation code generator)
	go get -u github.com/envoyproxy/protoc-gen-validate@$(PROTOC_PGV_VERSION)

dev/install/ginkgo: ## Bootstrap: Install Ginkgo (BDD testing framework)
	# see https://github.com/onsi/ginkgo#set-me-up
	echo "Installing Ginkgo ..."
	go get -u github.com/onsi/ginkgo/ginkgo  # installs the ginkgo CLI
	echo "Ginkgo has been installed at $(GOPATH_BIN_DIR)/ginkgo"
	echo "Installing Gomega ..."
	go get -u github.com/onsi/gomega/...     # fetches the matcher library
	echo "Gomega has been installed"

dev/install/kubebuilder: ## Bootstrap: Install Kubebuilder (including etcd and kube-apiserver)
	# see https://book.kubebuilder.io/quick-start.html#installation
	@if [ -e $(KUBEBUILDER_PATH) ]; then echo "Kubebuilder $$( $(KUBEBUILDER_PATH) version ) is already installed at $(KUBEBUILDER_PATH)" ; fi
	@if [ ! -e $(KUBEBUILDER_PATH) -a -d $(KUBEBUILDER_DIR) ]; then echo "Can not install Kubebuilder since directory $(KUBEBUILDER_DIR) already exists. Please remove/rename it and try again" ; false ; fi
	@if [ ! -e $(KUBEBUILDER_PATH) ]; then \
		echo "Installing Kubebuilder $(CI_KUBEBUILDER_VERSION) ..." \
		&& set -x \
		&& curl -L https://go.kubebuilder.io/dl/$(CI_KUBEBUILDER_VERSION)/$(GOOS)/$(GOARCH) | tar -xz -C /tmp/ \
		&& mkdir -p $(KUBEBUILDER_DIR) \
		&& cp -r /tmp/kubebuilder_$(CI_KUBEBUILDER_VERSION)_$(GOOS)_$(GOARCH)/* $(KUBEBUILDER_DIR) \
		&& rm -rf /tmp/kubebuilder_$(CI_KUBEBUILDER_VERSION)_$(GOOS)_$(GOARCH) \
        && for tool in $$( ls $(KUBEBUILDER_DIR)/bin ) ; do if [ ! -e $(CI_TOOLS_DIR)/$${tool} ]; then ln -s $(KUBEBUILDER_DIR)/bin/$${tool} $(CI_TOOLS_DIR)/$${tool} ; echo "Installed $(CI_TOOLS_DIR)/$${tool}" ; else echo "$(CI_TOOLS_DIR)/$${tool} already exists" ; fi; done \
		&& set +x \
		&& echo "Kubebuilder $(CI_KUBEBUILDER_VERSION) has been installed at $(KUBEBUILDER_PATH)" ; fi

dev/install/kustomize: ## Bootstrap: Install Kustomize
	# see https://book.kubebuilder.io/quick-start.html#installation
	@if [ -e $(KUSTOMIZE_PATH) ]; then echo "Kustomize $$( $(KUSTOMIZE_PATH) version ) is already installed at $(KUSTOMIZE_PATH)" ; fi
	@if [ ! -e $(KUSTOMIZE_PATH) ]; then \
		echo "Installing Kustomize latest ..." \
		&& set -x \
		&& curl -Lo kustomize https://go.kubebuilder.io/kustomize/$(GOOS)/$(GOARCH) \
		&& chmod +x kustomize \
		&& mkdir -p $(KUBEBUILDER_DIR)/bin \
		&& mv kustomize $(KUBEBUILDER_DIR)/bin/ \
		&& ln -s $(KUBEBUILDER_DIR)/bin/kustomize $(KUSTOMIZE_PATH) \
		&& set +x \
		&& echo "Kustomize latest has been installed at $(KUSTOMIZE_PATH)" ; fi

dev/install/kubectl: ## Bootstrap: Install kubectl
	# see https://kubernetes.io/docs/tasks/tools/install-kubectl/#install-kubectl-binary-with-curl-on-linux
	@if [ -e $(KUBECTL_PATH) ]; then echo "Kubectl $$( $(KUBECTL_PATH) version ) is already installed at $(KUBECTL_PATH)" ; fi
	@if [ ! -e $(KUBECTL_PATH) ]; then \
		echo "Installing Kubectl $(CI_KUBECTL_VERSION) ..." \
		&& set -x \
		&& curl -LO https://storage.googleapis.com/kubernetes-release/release/$(CI_KUBECTL_VERSION)/bin/$(GOOS)/$(GOARCH)/kubectl \
		&& chmod +x kubectl \
		&& mkdir -p $(CI_TOOLS_DIR) \
		&& mv kubectl $(KUBECTL_PATH) \
		&& set +x \
		&& echo "Kubectl $(CI_KUBECTL_VERSION) has been installed at $(KUBECTL_PATH)" ; fi

dev/install/kind: ## Bootstrap: Install KIND (Kubernetes in Docker)
	# see https://kind.sigs.k8s.io/docs/user/quick-start/#installation
	@if [ -e $(KIND_PATH) ]; then echo "Kind $$( $(KIND_PATH) version ) is already installed at $(KIND_PATH)" ; fi
	@if [ ! -e $(KIND_PATH) ]; then \
		echo "Installing Kind $(CI_KIND_VERSION) ..." \
		&& set -x \
		&& curl -Lo kind https://github.com/kubernetes-sigs/kind/releases/download/$(CI_KIND_VERSION)/kind-$(GOOS)-$(GOARCH) \
		&& chmod +x kind \
		&& mkdir -p $(CI_TOOLS_DIR) \
		&& mv kind $(KIND_PATH) \
		&& set +x \
		&& echo "Kind $(CI_KIND_VERSION) has been installed at $(KIND_PATH)" ; fi

dev/install/minikube: ## Bootstrap: Install Minikube
	# see https://kubernetes.io/docs/tasks/tools/install-minikube/#linux
	@if [ -e $(MINIKUBE_PATH) ]; then echo "Minikube $$( $(MINIKUBE_PATH) version ) is already installed at $(MINIKUBE_PATH)" ; fi
	@if [ ! -e $(MINIKUBE_PATH) ]; then \
		echo "Installing Minikube $(CI_MINIKUBE_VERSION) ..." \
		&& set -x \
		&& curl -Lo minikube https://storage.googleapis.com/minikube/releases/$(CI_MINIKUBE_VERSION)/minikube-$(GOOS)-$(GOARCH) \
		&& chmod +x minikube \
		&& mkdir -p $(CI_TOOLS_DIR) \
		&& mv minikube $(MINIKUBE_PATH) \
		&& set +x \
		&& echo "Minikube $(CI_MINIKUBE_VERSION) has been installed at $(MINIKUBE_PATH)" ; fi

start/k8s: start/kind deploy/example-app/k8s ## Bootstrap: Start Kubernetes locally (KIND) and deploy sample app

start/kind:
	kind create cluster --name konvoy 2>/dev/null || true
	@echo
	@echo '>>> You need to manually run the following command in your shell: >>>'
	@echo
	@echo export KUBECONFIG="$$(kind get kubeconfig-path --name=konvoy)"
	@echo
	@echo '<<< ------------------------------------------------------------- <<<'
	@echo

deploy/example-app/k8s:
	KUBECONFIG=$(KIND_KUBECONFIG) kubectl create namespace $(EXAMPLE_NAMESPACE) || true
	KUBECONFIG=$(KIND_KUBECONFIG) kubectl label namespace $(EXAMPLE_NAMESPACE) getkonvoy.io/sidecar-injection=enabled --overwrite
	KUBECONFIG=$(KIND_KUBECONFIG) kubectl apply -n $(EXAMPLE_NAMESPACE) -f examples/local/demo-app.yaml
	KUBECONFIG=$(KIND_KUBECONFIG) kubectl wait --timeout=60s --for=condition=Available -n konvoy-demo deployment/demo-app
	KUBECONFIG=$(KIND_KUBECONFIG) kubectl wait --timeout=60s --for=condition=Ready -n konvoy-demo pods -l app=demo-app

kind/load/control-plane: image/konvoy-cp
	kind load docker-image $(KONVOY_CP_DOCKER_IMAGE) --name=konvoy

kind/load/konvoy-dp: image/konvoy-dp
	kind load docker-image $(KONVOY_DP_DOCKER_IMAGE) --name=konvoy

kind/load/konvoy-injector: image/konvoy-injector
	kind load docker-image $(KONVOY_INJECTOR_DOCKER_IMAGE) --name=konvoy

deploy/control-plane/k8s: build/konvoyctl
	KUBECONFIG=$(KIND_KUBECONFIG) konvoyctl install control-plane | kubectl apply -f -
	KUBECONFIG=$(KIND_KUBECONFIG) kubectl delete -n konvoy-system pod -l app=konvoy-injector
	KUBECONFIG=$(KIND_KUBECONFIG) kubectl wait --timeout=60s --for=condition=Available -n konvoy-system deployment/konvoy-injector
	KUBECONFIG=$(KIND_KUBECONFIG) kubectl wait --timeout=60s --for=condition=Ready -n konvoy-system pods -l app=konvoy-injector

start/control-plane/k8s: kind/load/control-plane kind/load/konvoy-dp kind/load/konvoy-injector deploy/control-plane/k8s ## Bootstrap: Deploy Control Plane on Kubernetes (KIND)

clean: clean/build ## Dev: Clean

clean/build: ## Dev: Remove build/ dir
	rm -rf "$(BUILD_DIR)"

clean/proto: ## Dev: Remove auto-generated Protobuf files
	find $(PROTO_DIR) -name '*.pb.go' -delete
	find $(PROTO_DIR) -name '*.pb.validate.go' -delete

generate: clean/proto protoc/pkg/config/app/konvoyctl/v1alpha1 ## Dev: Run code generators

protoc/pkg/config/app/konvoyctl/v1alpha1:
	$(PROTOC_GO) pkg/config/app/konvoyctl/v1alpha1/*.proto

# Notice that this command is not include into `make generate` by intention (since generated code differes between dev host and ci server)
generate/konvoyctl/install/control-plane:
	go generate ./app/konvoyctl/pkg/install/k8s/control-plane/...

fmt: fmt/go fmt/proto ## Dev: Run various format tools

fmt/go: ## Dev: Run go fmt
	go fmt ./...
	@# apparently, it's not possible to simply use `go fmt ./pkg/plugins/resources/k8s/native/...`
	make fmt -C pkg/plugins/resources/k8s/native

fmt/proto: ## Dev: Run clang-format on .proto files
	find . -name '*.proto' | xargs -L 1 $(CLANG_FORMAT_PATH) -i

vet: ## Dev: Run go vet
	go vet ./...
	@# for consistency with `fmt`
	make vet -C pkg/plugins/resources/k8s/native

check: generate fmt vet docs ## Dev: Run code checks (go fmt, go vet, ...)
	make generate manifests -C pkg/plugins/resources/k8s/native
	git diff --quiet || test $$(git diff --name-only | grep -v -e 'go.mod$$' -e 'go.sum$$' | wc -l) -eq 0 || ( echo "The following changes (result of code generators and code checks) have been detected:" && git --no-pager diff && false ) # fail if Git working tree is dirty

test: ## Dev: Run tests
	mkdir -p "$(shell dirname "$(COVERAGE_PROFILE)")"
	go test $(GO_TEST_OPTS) -race -covermode=atomic -coverpkg=./... -coverprofile="$(COVERAGE_PROFILE)" $(PKG_LIST)
	go tool cover -html="$(COVERAGE_PROFILE)" -o "$(COVERAGE_REPORT_HTML)"

integration: ## Dev: Run integration tests
	mkdir -p "$(shell dirname "$(COVERAGE_INTEGRATION_PROFILE)")"
	tools/test/run-integration-tests.sh "go test -race -covermode=atomic -tags=integration -count=1 -coverpkg=./... -coverprofile=$(COVERAGE_INTEGRATION_PROFILE) $(PKG_LIST)"
	go tool cover -html="$(COVERAGE_INTEGRATION_PROFILE)" -o "$(COVERAGE_INTEGRATION_REPORT_HTML)"

build: build/konvoy-cp build/konvoy-dp build/konvoyctl build/konvoy-injector ## Dev: Build all binaries

build/konvoy-cp: ## Dev: Build `Control Plane` binary
	CGO_ENABLED=0 go build -ldflags="-s -w" -v -o ${BUILD_ARTIFACTS_DIR}/konvoy-control-plane/konvoy-control-plane ./app/konvoy-cp

build/konvoy-dp: ## Dev: Build `konvoy-dataplane` binary
	CGO_ENABLED=0 go build -ldflags="-s -w" -v -o ${BUILD_ARTIFACTS_DIR}/konvoy-dataplane/konvoy-dataplane ./app/konvoy-dp

build/konvoyctl: ## Dev: Build `konvoyctl` binary
	CGO_ENABLED=0 go build -ldflags="-s -w" -v -o $(BUILD_KONVOYCTL_DIR)/konvoyctl ./app/konvoyctl

build/konvoy-injector: ## Dev: Build `konvoy-injector` binary
	CGO_ENABLED=0 go build -ldflags="-s -w" -v -o ${BUILD_ARTIFACTS_DIR}/konvoy-injector/konvoy-injector ./app/konvoy-injector

run/k8s: fmt vet ## Dev: Run Control Plane locally in Kubernetes mode
	KUBECONFIG=$(KIND_KUBECONFIG) make crd/upgrade -C pkg/plugins/resources/k8s/native
	KUBECONFIG=$(KIND_KUBECONFIG) \
	KONVOY_GRPC_PORT=$(CP_GRPC_PORT) \
    KONVOY_HTTP_PORT=$(CP_HTTP_PORT) \
    KONVOY_ENVIRONMENT=kubernetes \
    KONVOY_STORE_TYPE=kubernetes \
	go run ./app/konvoy-cp/main.go run

run/universal/memory: fmt vet ## Dev: Run Control Plane locally in universal mode with in-memory store
	KONVOY_GRPC_PORT=$(CP_GRPC_PORT) \
	KONVOY_HTTP_PORT=$(CP_HTTP_PORT) \
	KONVOY_ENVIRONMENT=universal \
	KONVOY_STORE_TYPE=memory \
	go run ./app/konvoy-cp/main.go run

start/postgres: ## Boostrap: start Postgres for Control Plane with initial schema
	docker-compose -f tools/postgres/docker-compose.yaml up $(DOCKER_COMPOSE_OPTIONS) -d
	tools/postgres/wait-for-postgres.sh 15432

run/universal/postgres: fmt vet ## Dev: Run Control Plane locally in universal mode with Postgres store
	KONVOY_GRPC_PORT=$(CP_GRPC_PORT) \
	KONVOY_HTTP_PORT=$(CP_HTTP_PORT) \
	KONVOY_ENVIRONMENT=universal \
	KONVOY_STORE_TYPE=postgres \
	KONVOY_STORE_POSTGRES_HOST=localhost \
	KONVOY_STORE_POSTGRES_PORT=15432 \
	KONVOY_STORE_POSTGRES_USER=konvoy \
	KONVOY_STORE_POSTGRES_PASSWORD=konvoy \
	KONVOY_STORE_POSTGRES_DB_NAME=konvoy \
	go run ./app/konvoy-cp/main.go run

curl/listeners: EXAMPLE_ENVOY_ID=$(KIND_EXAMPLE_ENVOY_ID)
curl/listeners: ## Dev: Make Discovery request to LDS
	curl -s $(CP_BIND_HOST):$(CP_HTTP_PORT)/v2/discovery:listeners --data-binary $(SIMPLE_DISCOVERY_REQUEST)

curl/clusters: EXAMPLE_ENVOY_ID=$(KIND_EXAMPLE_ENVOY_ID)
curl/clusters: ## Dev: Make Discovery request to CDS
	curl -s $(CP_BIND_HOST):$(CP_HTTP_PORT)/v2/discovery:clusters --data-binary $(SIMPLE_DISCOVERY_REQUEST)

run/example/envoy: EXAMPLE_ENVOY_ID=$(KIND_EXAMPLE_ENVOY_ID)
run/example/envoy: build/konvoy-dp ## Dev: Run Envoy configured against local Control Plane
	KONVOY_CONTROL_PLANE_XDS_SERVER_ADDRESS=localhost \
	KONVOY_CONTROL_PLANE_XDS_SERVER_PORT=5678 \
	KONVOY_DATAPLANE_ID=$(EXAMPLE_ENVOY_ID) \
	KONVOY_DATAPLANE_SERVICE=$(EXAMPLE_ENVOY_CLUSTER) \
	KONVOY_DATAPLANE_ADMIN_PORT=$(ENVOY_ADMIN_PORT) \
	${BUILD_ARTIFACTS_DIR}/konvoy-dataplane/konvoy-dataplane run

config_dump/example/envoy: ## Dev: Dump effective configuration of example Envoy
	curl -s localhost:$(ENVOY_ADMIN_PORT)/config_dump

images: image/konvoy-cp image/konvoy-dp image/konvoyctl image/konvoy-injector ## Dev: Build all Docker images

image/konvoy-cp: ## Dev: Build `konvoy-control-plane` Docker image
	docker build -t $(KONVOY_CP_DOCKER_IMAGE) -f Dockerfile.konvoy-cp .

image/konvoy-dp: ## Dev: Build `konvoy-dataplane` Docker image
	docker build -t $(KONVOY_DP_DOCKER_IMAGE) -f Dockerfile.konvoy-dp .

image/konvoyctl: ## Dev: Build `konvoyctl` Docker image
	docker build -t $(KONVOYCTL_DOCKER_IMAGE) -f Dockerfile.konvoyctl .

image/konvoy-injector: ## Dev: Build `konvoy-injector` Docker image
	docker build -t $(KONVOY_INJECTOR_DOCKER_IMAGE) -f Dockerfile.konvoy-injector .

image/konvoy-cp/push: image/konvoy-cp\
	docker login -u $(BINTRAY_USERNAME) -p $(BINTRAY_API_KEY) $(BINTRAY_REGISTRY)
	docker tag $(KONVOY_CP_DOCKER_IMAGE) $(BINTRAY_REGISTRY)/konvoy-cp:$(KONVOY_VERSION)
	docker push $(BINTRAY_REGISTRY)/konvoy-cp:$(KONVOY_VERSION)
	docker logout $(BINTRAY_REGISTRY)

image/konvoy-dp/push: image/konvoy-dp
	docker login -u $(BINTRAY_USERNAME) -p $(BINTRAY_API_KEY) $(BINTRAY_REGISTRY)
	docker tag $(KONVOY_DP_DOCKER_IMAGE) $(BINTRAY_REGISTRY)/konvoy-dp:$(KONVOY_VERSION)
	docker push $(BINTRAY_REGISTRY)/konvoy-dp:$(KONVOY_VERSION)
	docker logout $(BINTRAY_REGISTRY)

image/konvoyctl/push: image/konvoyctl
	docker login -u $(BINTRAY_USERNAME) -p $(BINTRAY_API_KEY) $(BINTRAY_REGISTRY)
	docker tag $(KONVOY_DP_DOCKER_IMAGE) $(BINTRAY_REGISTRY)/konvoyctl:$(KONVOY_VERSION)
	docker push $(BINTRAY_REGISTRY)/konvoyctl:$(KONVOY_VERSION)
	docker logout $(BINTRAY_REGISTRY)

images/push: image/konvoy-cp/push image/konvoy-dp/push image/konvoyctl/push

docs: docs/konvoyctl ## Dev: Generate all docs

docs/konvoyctl: build/konvoyctl ## Dev: Generate `konvoyctl` docs
	tools/docs/konvoyctl/gen_help.sh ${BUILD_KONVOYCTL_DIR}/konvoyctl >docs/cmd/konvoyctl/HELP.md

print/kubebuilder/test_assets: ## Dev: Print Kubebuilder Environment variables
	@echo export TEST_ASSET_KUBE_APISERVER=$(TEST_ASSET_KUBE_APISERVER)
	@echo export TEST_ASSET_ETCD=$(TEST_ASSET_ETCD)
	@echo export TEST_ASSET_KUBECTL=$(TEST_ASSET_KUBECTL)

run/example/docker-compose: ## Docker Compose: Run demo setup
	docker-compose -f examples/docker-compose/docker-compose.yaml pull
	docker-compose -f examples/docker-compose/docker-compose.yaml up --build --no-start
	docker-compose -f examples/docker-compose/docker-compose.yaml up $(DOCKER_COMPOSE_OPTIONS)

wait/example/docker-compose: ## Docker Compose: Wait for demo setup to get ready
	docker run --network docker-compose_envoymesh --rm -ti $(CI_TOOLS_IMAGE) dockerize -wait http://demo-app:8080 -timeout 1m

curl/example/docker-compose: ## Docker Compose: Make sample requests to demo setup
	docker run --network docker-compose_envoymesh --rm -ti $(CI_TOOLS_IMAGE) sh -c 'set -e ; for i in `seq 1 10`; do test $$(curl -s http://demo-app:8080 | jq -r .url) = "http://mockbin.org/request" && echo "request #$$i successful" ; sleep 1 ; done'

stats/example/docker-compose: ## Docker Compose: Observe Envoy metrics from demo setup
	docker-compose -f examples/docker-compose/docker-compose.yaml exec envoy curl -s localhost:9901/stats/prometheus | grep upstream_rq_total

verify/example/docker-compose/inbound:
	@echo "Checking number of Inbound requests via Envoy ..."
	test $$( docker-compose --file examples/docker-compose/docker-compose.yaml exec envoy curl -s localhost:9901/stats/prometheus | grep 'envoy_cluster_upstream_rq_total{envoy_cluster_name="localhost_8080"}' | awk '{print $$2}' | tr -d [:space:] ) -ge 10
	@echo "Check passed!"

verify/example/docker-compose/outbound:
	@echo "Checking number of Outbound requests via Envoy ..."
	test $$( docker-compose --file examples/docker-compose/docker-compose.yaml exec envoy curl -s localhost:9901/stats/prometheus | grep 'envoy_cluster_upstream_rq_total{envoy_cluster_name="pass_through"}' | awk '{print $$2}' | tr -d [:space:] ) -ge 10
	@echo "Check passed!"

verify/example/docker-compose: verify/example/docker-compose/inbound verify/example/docker-compose/outbound ## Docker Compose: Verify Envoy stats (after sample requests)

build/example/minikube: ## Minikube: build demo setup
	eval $$(minikube docker-env) && $(MAKE) images

deploy/example/minikube: image/konvoyctl ## Minikube: deploy demo setup
	docker run --rm konvoy/konvoyctl konvoyctl install control-plane | kubectl apply -f -
	kubectl wait --timeout=60s --for=condition=Available -n konvoy-system deployment/konvoy-injector
	kubectl wait --timeout=60s --for=condition=Ready -n konvoy-system pods -l app=konvoy-injector
	kubectl apply -f examples/minikube/konvoy-demo/
	kubectl wait --timeout=60s --for=condition=Available -n konvoy-demo deployment/demo-app
	kubectl wait --timeout=60s --for=condition=Ready -n konvoy-demo pods -l app=demo-app

wait/example/minikube: ## Minikube: Wait for demo setup to get ready
	kubectl -n default run wait --rm -ti --restart=Never --image=$(CI_TOOLS_IMAGE) -- dockerize -wait http://demo-app.konvoy-demo:8000/request -timeout 1m

curl/example/minikube: ## Minikube: Make sample requests to demo setup
	kubectl -n default run curl --rm -ti --restart=Never --image=$(CI_TOOLS_IMAGE) -- sh -c 'set -e ; for i in `seq 1 10`; do test $$(curl -s http://demo-app.konvoy-demo:8000/request | jq -r .url) = "http://mockbin.org/request" && echo "request #$$i successful" ; sleep 1 ; done'

stats/example/minikube: ## Minikube: Observe Envoy metrics from demo setup
	kubectl -n konvoy-demo exec $$(kubectl -n konvoy-demo get pods -l app=demo-app -o=jsonpath='{.items[0].metadata.name}') -c konvoy-sidecar -- wget -qO- http://localhost:9901/stats/prometheus | grep upstream_rq_total

verify/example/minikube/inbound:
	@echo "Checking number of Inbound requests via Envoy ..."
	test $$( kubectl -n konvoy-demo exec $$(kubectl -n konvoy-demo get pods -l app=demo-app -o=jsonpath='{.items[0].metadata.name}') -c konvoy-sidecar -- wget -qO- http://localhost:9901/stats/prometheus | grep 'envoy_cluster_upstream_rq_total{envoy_cluster_name="localhost_8000"}' | awk '{print $$2}' | tr -d [:space:] ) -ge 10
	@echo "Check passed!"

verify/example/minikube/outbound:
	@echo "Checking number of Outbound requests via Envoy ..."
	test $$( kubectl -n konvoy-demo exec $$(kubectl -n konvoy-demo get pods -l app=demo-app -o=jsonpath='{.items[0].metadata.name}') -c konvoy-sidecar -- wget -qO- http://localhost:9901/stats/prometheus | grep 'envoy_cluster_upstream_rq_total{envoy_cluster_name="pass_through"}' | awk '{print $$2}' | tr -d [:space:] ) -ge 1
	@echo "Check passed!"

verify/example/minikube: verify/example/minikube/inbound verify/example/minikube/outbound ## Minikube: Verify Envoy stats (after sample requests)

konvoyctl/example/minikube: image/konvoyctl
	cat examples/minikube/konvoyctl_workflow.sh | docker run -i --rm --user $$(id -u):$$(id -g) --network host -v $$HOME/.kube:/tmp/.kube -v $$HOME/.minikube:$$HOME/.minikube -e HOME=/tmp -w /tmp $(KONVOYCTL_DOCKER_IMAGE)

generate/test/cert/konvoy-injector:  ## Dev: Generate TLS cert for Konvoy Injector (for use in development and unit tests)
	OUTPUT_DIR=$(shell pwd)/app/konvoy-injector/cmd/testdata && \
	TMP_DIR=$(shell mktemp -d) && \
	cd $$TMP_DIR && \
	go run $(shell go env GOROOT)/src/crypto/tls/generate_cert.go --host=*,*.konvoy-system.svc --duration=87660h && \
	mv cert.pem $$OUTPUT_DIR/tls.crt && \
	mv key.pem $$OUTPUT_DIR/tls.key && \
	rm -rf $$TMP_DIR

run/konvoy-injector: ## Dev: Run Konvoy Injector locally
	KUBECONFIG=$(KIND_KUBECONFIG) \
	KONVOY_INJECTOR_WEBHOOK_SERVER_CERT_DIR=$(shell pwd)/app/konvoy-injector/cmd/testdata \
	go run ./app/konvoy-injector/main.go run

test/konvoy-injector: PKG_LIST=./app/konvoy-injector/... ./pkg/config/app/konvoy-injector/...
test/konvoy-injector: test ## Dev: Run Konvoy Injector tests only

run/konvoy-dp: ## Dev: Run `konvoy-dataplane` locally
	KONVOY_CONTROL_PLANE_XDS_SERVER_ADDRESS=localhost \
	KONVOY_CONTROL_PLANE_XDS_SERVER_PORT=$(CP_GRPC_PORT) \
	KONVOY_DATAPLANE_ID=$(EXAMPLE_ENVOY_ID) \
	KONVOY_DATAPLANE_SERVICE=$(EXAMPLE_ENVOY_CLUSTER) \
	KONVOY_DATAPLANE_ADMIN_PORT=$(ENVOY_ADMIN_PORT) \
	go run ./app/konvoy-dp/main.go run

test/konvoy-dp: PKG_LIST=./app/konvoy-dp/... ./pkg/config/app/konvoy-dp/...
test/konvoy-dp: test ## Dev: Run `konvoy-dataplane` tests only
