# Migrating to consistent and well-defined naming for non-system Envoy resources and stats

* Status: accepted

## Context and problem statement

As described in the [Resource Identifier MADR](070-resource-identifier.md), we are standardizing xDS resource and Envoy stat naming using a structured format to improve consistency, traceability, and integration with tooling such as observability dashboards and the Kuma GUI. This effort introduces two major changes:

1. **KRI-based naming**: Used for resources that are a direct result of distinct Kuma resources like `MeshService`, `MeshGateway`, `MeshHTTPRoute`, and others. This format improves correlation between Envoy configuration and Kuma resources, making it easier to trace metrics, understand traffic behavior, and troubleshoot issues.

2. **`self_` naming format**: Used for inbound-related resources, which are currently always defined inside a `Dataplane`. These resources already exist in the context of the `Dataplane` that created them, so repeating that reference using a full KRI name does not add value and would unnecessarily raise metric cardinality. Instead, a simpler format like `self_{sectionName}` is used. In the future, if inbound resources can be defined by something other than a `Dataplane`, such as a new type of policy, then those resources will have their own identity and use full KRI naming.

While these formats improve structure and consistency, they differ from the current naming conventions used for Envoy resources and stats, which often follow legacy or default patterns. Right now, resource names and stat names are not aligned and can differ significantly, even when generated from the same Kuma resource. Changing them without care can disrupt existing observability setups that rely on these names.

To support the transition, a smooth migration path must be defined that introduces the new formats without disrupting existing environments.

## Affected systems and users

Two main groups are impacted:

* Internal systems: Kuma GUI
* External users: Dashboards, Prometheus

### Kuma GUI

The `Dataplane` view in the GUI shows inbound and outbound endpoints by parsing Envoy stat names such as clusters and listeners, and matching them to the config. Changes to how names are built will affect this matching. The GUI must be updated to support both old and new formats during the migration. This includes handling KRI-based names for outbound and routing resources, and `self_` names for inbounds. Unlike before, stat names and resource names will now match, so GUI logic must reflect that.

## Scope

This decision applies to environments using the new service discovery model:

* `MeshService`  
* `MeshExternalService`  
* `MeshMultiZoneService`

These resources replace the legacy `kuma.io/service` tag for describing services in the mesh. Since the legacy tag is being removed, this migration only affects naming for resources generated from the new model. Legacy-based setups are out of scope.

### Out of scope

This document does not cover renaming of Envoy resources that do not directly map to Kuma resources like `MeshHTTPRoute`, `MeshService`, or `MeshExternalService`. This includes system resources generated by Kuma, such as:

* Secrets  
* System listeners and clusters  
* Default routes (when no `MeshHTTPRoute` or `MeshTCPRoute` is defined)

Renaming of these system resources will be handled in a separate MADR.

The `MeshPassthrough` resource is not covered and may be addressed separately.

Support for the built-in gateway is also out of scope and may be handled in a separate effort.

## Decision outcome

Introduce a data plane feature flag to enable the new naming scheme for Envoy resources and stats. This includes:

* KRI-based names for resources tied to distinct Kuma resources like `MeshService`
* `self_` format for inbound-related resources defined inside a `Dataplane`

The flag can be enabled per proxy by setting an environment variable:

* Directly in Universal mode
* Indirectly in Kubernetes via a pod annotation, which is converted by the sidecar injector into the same environment variable and applied to the `kuma-sidecar` container

In Kubernetes, the control plane can be configured to auto-inject the annotation into all workloads during sidecar injection, turning the feature on by default for all proxies in the zone.

## Implementation

### Data plane feature flag and propagation

A new data plane feature flag will control the use of consistent naming for proxy resources and stats, including both KRI-based formats and the new `self_` format for inbounds. It will be optional at first, with a deprecation path: the new naming will become the default in the future, and the flag will eventually be removed. This gives users time to migrate without breaking existing setups.

The flag will be passed from the data plane proxy to the control plane via xDS metadata using:

```go
const FeatureProxyResourcesAndStatsNamingV2 string = "feature-proxy-resources-and-stats-naming-v2"
```

#### Per-proxy opt-in

Users can enable the feature for individual data plane proxies:

| Mode       | How to enable                                                                          |
|------------|----------------------------------------------------------------------------------------|
| Universal  | Set env var: `KUMA_DATAPLANE_RUNTIME_PROXY_RESOURCES_AND_STATS_NAMING_V2_ENABLED=true` |
| Kubernetes | Add annotation: `features.kuma.io/proxy-resources-and-stats-naming-v2: "enabled"`      |

In Kubernetes, we cannot rely on setting the environment variable directly because environment variables are container-scoped, not pod-scoped. Since the `kuma-sidecar` container is injected into the pod by the sidecar injector, setting the environment variable on the user’s workload container would not affect the sidecar container. Therefore, the only viable and generic way to control this feature per pod is to use an annotation. The sidecar injector reads the annotation and converts it into the correct environment variable on the `kuma-sidecar` container. `kuma-dp` will then pick up the variable and include the feature flag in the xDS metadata sent to the control plane.

**This annotation follows a new convention for data plane feature flags: all new per-pod feature flags will use the `features.` prefix.** This aligns with Kubernetes annotation guidelines, which recommend that prefixes carry context and follow the pattern `subsystem.kubernetes.io/parameter` over flat or ambiguous keys. See [Kubernetes API Conventions](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#label-selector-and-annotation-conventions) for details.

#### Zone-wide opt-in for Kubernetes data planes

To enable the naming changes for all injected data plane proxies in a Kubernetes zone, users can configure the control plane to automatically inject the annotation during sidecar injection:

```go
ProxyResourcesAndStatsNamingV2Enabled bool `json:"proxyResourcesAndStatsNamingV2Enabled" envconfig:"KUMA_RUNTIME_KUBERNETES_INJECTOR_PROXY_RESOURCES_AND_STATS_NAMING_V2_ENABLED"`
```

#### ZoneIngress and ZoneEgress

`ZoneIngress` and `ZoneEgress` proxies must also include the feature flag to ensure consistent naming accross the mesh. In both Universal and Kubernetes, this is done by setting the following environment variable in their deployments:

```env
KUMA_DATAPLANE_RUNTIME_PROXY_RESOURCES_AND_STATS_NAMING_V2_ENABLED=true
```

#### Helper setting for Kubernetes installations

To simplify configuration, a new setting will be introduced under the `dataPlane.features` section for Helm and other Kubernetes-based install methods:

```yaml
dataPlane:
  features:
    proxyResourcesAndStatsNamingV2: true
```

When enabled, it will:

* Add `KUMA_DATAPLANE_RUNTIME_PROXY_RESOURCES_AND_STATS_NAMING_V2_ENABLED=true` to all `ZoneIngress` and `ZoneEgress` deployments
* Set `KUMA_RUNTIME_KUBERNETES_INJECTOR_PROXY_RESOURCES_AND_STATS_NAMING_V2_ENABLED=true` in the control plane deployment

When the new naming becomes the default, this setting will also default to `true`. Eventually, it will be removed when the feature can no longer be disabled.

### Naming for inbound-related resources

The current KRI naming format, as defined in the [Resource Identifier](070-resource-identifier.md) MADR, proposes that non-system inbound resources (such as listeners and clusters) use the full KRI name of the originating `Dataplane` plus the inbound port or name as the `sectionName`. This would result in names like:

```
kri_dp_default_kuma-2_kuma-demo_demo-app-ddd8546d5-vg5ql_5050
```

While technically correct and traceable, this causes a significant increase in metrics cardinality compared to current formats like `localhost_5050` (used for cluster stat names). For listeners, where the format was not explicitly defined by us, the names defaulted to Envoy’s format like `{address}_{port}`. This would lead to regressions in performance, cost, and compatibility with observability tooling. The following alternatives are considered:

#### Option 1: Introduce a separate naming scheme for inbound resources using `self` or `this` keyword

This option proposes a new naming format specifically for non-system inbound xDS resources. Instead of using the full KRI (which includes the `Dataplane` name) or the system format (which uses the `system_` prefix), these resources would follow a distinct format based on the `self` or `this` keyword:

```
self_5050  
self_httpport
```

The format uses an underscore separator and may include either the port number or the named port, depending on the `Dataplane` configuration.

This approach introduces a third well-defined and consistent naming scheme:

* `kri_` prefix: used for Kuma resource–based names
* `system_` prefix: used for system resources
* `self_` (or `this_`) prefix: used for contextual inbound resources that belong to a specific `Dataplane`

The main justification is that inbound resources always exist in the context of the `Dataplane` that defines them. Unlike outbounds (which are tied to another named resource), inbounds are local and self-contained. If we try to use KRI format and remove the `Dataplane` name, we break the KRI's purpose of clearly correlating the name with the originating resource. Therefore, a dedicated and simple contextual naming format is more accurate and practical.

**Benefits:**

* No increase in metric cardinality
* Keeps stat and resource names short and practical
* Minimal changes to existing tooling: `localhost_*` just becomes `self_*` or `this_*`
* Format avoids confusion with system resources (no `system_` prefix)
* No `kri_` prefix makes it clear this is not KRI-based, avoiding incorrect expectations in tooling
* Avoids metric churn in Kubernetes by not embedding pod-specific values
* Supports named ports in addition to numeric ports
* Establishes a clear, purpose-specific format for inbounds that fits their context

**Drawbacks:**

* Introduces a third naming category outside the original Resource Identifier MADR, requiring updates to formally define and support it
* Removes the ability to directly correlate inbound resource names with their originating `Dataplane`
* Increases complexity by maintaining and reasoning about three separate naming formats across the system

#### Option 2: Align resource names with existing `localhost_{port}` inbound clusters stat format

This option proposes using the already established stat format `localhost_{port}` (currently used for inbound Envoy cluster stats) as the unified name for all related xDS resources such as clusters and listeners.

Specifically:

* Change cluster names from `localhost:{port}` to `localhost_{sectionName}` to match stat format
* Change listener and other inbound-related resource names (e.g. from `inbound:10.42.0.83:5050`) to `localhost_{sectionName}` for consistency across resources

Unlike current formats, this allows `{sectionName}` to be either a port number or a named port (e.g. `httpport`).

**Examples:**

* `localhost_5050`
* `localhost_httpport`

**Benefits:**

* Keeps resource names in sync with existing `localhost_{port}` stat format for clusters, as long as no port name is used
* No increase in metric cardinality
* Dashboards and alerts using current cluster stat names will continue to work without changes when numeric ports are used
* Builds on a format already familiar to users

**Drawbacks:**

* Listener stat names will change, which may require updates to dashboards or alerts that rely on them
* The prefix `localhost_` may be misleading for listeners, which typically bind to pod IPs, not loopback
* Breaks the original Resource Identifier model by introducing a third category of resources outside Kuma-based and system types
* Reduces consistency in naming format across all xDS resource types and stats

#### Option 3: Use modified KRI with placeholder in place of `Dataplane` name

This option preserves the structure of the original KRI format but modifies the `Dataplane`-related sections to avoid high cardinality. There are three suboptions for how to handle the `Dataplane` identity portion of the name:

##### Suboption A: Replace `Dataplane` name with a keyword like `self`, `this`, or leave it empty

Examples:

* `kri_dp_default_kuma-2_kuma-demo_self_5050`
* `kri_dp_default_kuma-2_kuma-demo_this_5050`
* `kri_dp_default_kuma-2_kuma-demo__5050`

**Benefits:**

* Lower cardinality compared to full `Dataplane` name
* Retains full KRI structure with readable, recognizable identity
* Clear and straightforward for users and tools to recognize and match

**Drawbacks:**

* If a user names their `Dataplane` `self` or `this`, the name will look like a valid KRI but won’t be correct. It won’t match the real `Dataplane` name and can be confusing
* Leaving the name section empty may look broken or incomplete even if technically valid
* Breaks the original Resource Identifier model by introducing a special case for inbounds that does not align with the two existing categories
* Reduces consistency in the overall naming convention
* Still includes mesh, zone, and namespace, which are already present as metric labels

##### Suboption B: Replace `Dataplane` name with a `-` to indicate hidden value

Example:

* `kri_dp_default_kuma-2_kuma-demo_-_5050`

The `-` acts as a placeholder to signal that the value exists but is intentionally omitted or obfuscated. This approach avoids using reserved or meaningful terms like `self`.

**Benefits:**

* Same as Suboption A
* Avoids name collision with user-defined `Dataplane` names like `self` or `this`
* Opens the path to extending the KRI format definition to support `-` as a special reserved marker for any KRI section

**Drawbacks:**

* Still includes mesh, zone, and namespace, contributing to metric cardinality
* Requires updates to the KRI MADR to define the semantics of `-`
* Less intuitive than using keywords and may need extra explanation

##### Suboption C: Collapse all KRI sections before `sectionName` into `-`

Example:

* `kri_dp_-_-_-_-_5050`

**Benefits:**

* Keeps KRI format while minimizing cardinality
* No risk of naming collisions or ambiguity
* Can be formally described in the KRI specification as a valid but anonymized identifier

**Drawbacks:**

* Looks awkward and artificial
* May confuse users and tooling — resource names like `kri_dp_-_-_-_-_5050` are syntactically valid but visually obscure
* Loses most of the traceability benefit of KRI
* Requires KRI spec to explicitly allow this pattern and define its meaning
* Still includes the `kri_` prefix, which might falsely suggest the name is fully qualified and traceable

#### Option 4: Treat inbounds as "system" resources and use `system_{prefix}_{sectionName}` format

Adjust the **Standardized Naming for internal xDS Resources** and [Resource Identifier](070-resource-identifier.md) MADRs by:

* Including non-system inbounds in the `system` category
* Using names like `system_self_5050` or `system_this_5050`

**Benefits:**

* No increase in metric cardinality
* Small changes to tools (e.g., replace `localhost_*` with `system_self_*`)

**Drawbacks:**

* Strongly contradicts the purpose of the system resource category, which is meant for internal, non-user-facing entities. Inbounds are tied to user configuration and traffic, so including them breaks this separation
* Users and tools that ignore `system_*` resources may unintentionally miss inbound data
* Requires documentation and tooling exceptions
* Forces major changes to the **Standardized Naming for internal xDS Resources** MADR

#### Option 5: Use full KRI name for resources, simplified name for stats

In this option, the Envoy resource names (used in xDS configuration) would follow the full KRI format as originally defined:

```
kri_dp_default_kuma-2_kuma-demo_demo-app-ddd8546d5-vg5ql_5050
```

However, the stat names would use a simplified format as described in earlier options, for example:

```
self_5050
```

**Benefits:**

* No increase in metric cardinality
* Keeps the xDS resources traceable via full KRI names
* One side (stats or resources) remains compatible with the original KRI format

**Drawbacks:**

* Breaks the promise in the Resource Identifier MADR that stat names and resource names would be aligned and consistent
* Makes it harder to correlate stats with resources in tooling like the Kuma GUI, which would now need to handle both formats separately
* Requires dual parsing and matching logic in Kuma GUI (e.g., different strategies for xDS config vs. stats)
* Increases implementation complexity and potential for confusion when debugging or inspecting proxy behavior

#### Chosen approach for inbound resource naming

We will go with **Option 1: Introduce a separate naming scheme for inbound resources using the `self` keyword**. This approach avoids the high cardinality problem of full KRI-formatted names and keeps tooling changes minimal by building on familiar patterns.

The new naming format will be used consistently for both xDS resource names and stat names associated with non-system inbound traffic. It will follow the pattern:

* `self_5050`
* `self_httpport`

This makes the resource identity clear and contextual to the `Dataplane`, without embedding full KRI metadata that would otherwise increase metric churn and complexity. Among the options discussed, this one offers the best balance between simplicity, compatibility with existing tooling, and clear semantics. It introduces a new, dedicated naming category for inbounds that reflects their contextual nature without overloading the existing `kri_` or `system_` prefixes.

### Impact on `MeshProxyPatch` policies

Enabling the new naming formats (`kri_` and `self_`) may break existing `MeshProxyPatch` policies that rely on old resource names. These patches often target specific cluster or listener names, and any mismatch caused by the updated naming will prevent the patch from applying.

Several ideas were considered to help detect or prevent breakage, but none were viable:

* Emit a warning when a `MeshProxyPatch` matches a proxy but none of its modifiers apply. However, patches like JSON Patch are complex and hard to analyze. Logging unmatched cases would likely produce too much noise and lead to false positives.

* Scan patches for the presence of `kri_` or `self_` prefixes as an indicator of awareness. This would be fragile and could not reliably detect incompatible patches.

* Show a general warning in the GUI when KRI is enabled and any `MeshProxyPatch` is active. This might help initially but would quickly become repetitive and unhelpful once users confirm their setups.

Since there’s no clean way to catch or warn about this in code, the decision is to document the risk clearly. Users are expected to:

* Review and update their `MeshProxyPatch` policies before enabling the new naming formats

As part of updating the documentation, we will:

* Add a strong warning to the `MeshProxyPatch` section explaining that policies must be reviewed and updated when switching to the new naming formats
* Include a notice in the upgrade notes to alert users of this requirement

### Updating ZoneIgress and ZoneEgress insight resources with feature flags

To support the Kuma GUI in adapting to KRI-based naming, we need to expose feature flag information in `ZoneIngressIngress` and `ZoneEgressIngress` resources, similar to how it's already done for `DataplaneIngress`. These insights resources are available via the control plane API and provide a summary of runtime state and metadata.

We will update both `ZoneIngressIngress` and `ZoneEgressIngress` to include metadata with active feature flags. This will allow the GUI to detect whether KRI naming is enabled for each proxy and adjust its behavior accordingly.

## Migration

### Kuma GUI

The Kuma GUI relies on Envoy stat names and xDS resource names to display inbound and outbound endpoint details for `Dataplane`, `ZoneIngress`, and `ZoneEgress` proxies. These names are used to associate metrics with specific resources and visualize traffic paths in the GUI.

To support the KRI naming format, the GUI parsers that extract resource information from stat names and xDS configuration (listeners, clusters, endpoints) must be updated. The new format is defined in the [Resource Identifier MADR](https://github.com/kumahq/kuma/blob/d19b78a4556962f4d9d3cc5921c7bdc73dc93d26/docs/madr/decisions/070-resource-identifier.md?plain=1#L328):

```
kri_<resource-type>_<mesh>_<zone>_<namespace>_<resource-name>_<section-name>
```

When the `feature-kri-naming` flag is present in the metadata of `DataplaneIngress`, `ZoneIngressIngress`, and `ZoneEgressInsight`, the GUI must:

* Parse and interpret stat names and xDS resource names based on the KRI format
* Drop any assumptions about `inbound:` or `outbound:` prefixes, which are no longer used
* Match stat names directly to xDS resource names, which now correspond 1:1

**Examples of KRI-formatted resource names:**

* `kri_dp_mesh-1_us-east-2_kuma-demo_backend-app_8080`
* `kri_msvc_mesh-1_us-east-2_kuma-demo_backend_httpport`
* `kri_mzsvc_mesh-1__kuma-system_backend-app_8080`
* `kri_mhttpr_mesh-1_us-east-2_kuma-demo_route-1_`
* `kri_extsvc_mesh-1__kuma-system_es1_`

**Examples of stats using KRI-formatted names:**

* `cluster.kri_msvc_mesh-1_us-east-2_kuma-demo_backend_httpport.upstream_cx_active: 0`
* `cluster.kri_mzsvc_mesh-1__kuma-system_backend-app_8080.upstream_cx_active: 0`
* `cluster.kri_dp_mesh-1_us-east-2_kuma-demo_backend-app_8080.upstream_cx_active: 0`
* `http.kri_msvc_mesh-1_us-east-2_kuma-demo_backend_httpport.downstream_cx_active: 0`
* `http.kri_mzsvc_mesh-1__kuma-system_backend-app_8080.downstream_cx_active: 0`
* `http.kri_dp_mesh-1_us-east-2_kuma-demo_backend-app_8080.downstream_cx_active: 0`
* `listener.kri_msvc_mesh-1_us-east-2_kuma-demo_backend_httpport.downstream_cx_active: 0`
* `listener.kri_mzsvc_mesh-1__kuma-system_backend-app_8080.downstream_cx_active: 0`
* `listener.kri_dp_mesh-1_us-east-2_kuma-demo_backend-app_8080.downstream_cx_active: 0`

## Test scenarios required for completion

The following scenarios must be verified to consider the work complete. Each case ensures the correct generation and usage of KRI-based resource and stat names across various deployment modes.

### Single-zone deployments

* `MeshService` is targeted directly by a `Dataplane` in the same zone
* `MeshExternalService` is targeted by a `Dataplane` via the `ZoneEgress` in the same zone

### Multi-zone with ZoneEgress and ZoneIngress (Global + 2 zones)

* `Dataplane` in zone 1 targets a `MeshService` in zone 2
* `Dataplane` in zone 1 targets a `MeshExternalService` in zone 1
* `Dataplane` in zone 1 targets a `MeshMultiZoneService` in zone 2
* `Dataplane` in zone 1 targets a `MeshMultiZoneService` in zone 2 with locality awareness disabled via `MeshLoadBalancingStrategy`

### Multi-zone with only ZoneIngress (Global + 2 zones)

* `Dataplane` in zone 1 targets a `MeshService` in zone 2
* `Dataplane` in zone 1 targets a `MeshMultiZoneService` in zone 1
* `Dataplane` in zone 2 targets a `MeshMultiZoneService` in zone 2 with locality awareness disabled via `MeshLoadBalancingStrategy`

### Multi-zone with ZoneIngress in both zones and ZoneEgress in one zone (Global + 2 zones)

* `Dataplane` in zone 1 targets a `MeshService` in zone 2
* `Dataplane` in zone 2 targets a `MeshService` in zone 1
* `Dataplanes` in both zones target a `MeshMultiZoneService` in their respective zones
* `Dataplanes` in both zones target a `MeshMultiZoneService` with locality awareness disabled via `MeshLoadBalancingStrategy`
