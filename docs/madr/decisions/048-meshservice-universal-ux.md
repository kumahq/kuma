# `MeshService` Universal UX

* Status: accepted

## Context and Problem Statement

There are two existing flows to add data plane proxy to a mesh on universal deployments:
* Direct - you pass `Dataplane` object to `kuma-dp` process and CP creates `Dataplane` object in DB when Envoy joins.
* Indirect - you create `Dataplane` on CP first and then reference this Dataplane when you run `kuma-dp` process.
With direct as a recommended way.

`MeshService` changes this, because we now need two objects to start a communication, `Dataplane` and `MeshService`.

## Considered Options

* `MeshService` manually applied on Zone CP
* `MeshService` autogenerated explicitly
* `MeshService` autogenerated implicitly

## Decision Outcome

`MeshService` autogenerated implicitly, because it does not break existing flow, and it does not bring complexity of MeshServiceGenerator.

### `MeshService` manually applied on Zone CP

A user needs to additionally apply `MeshService` on Zone CP.

**Advantages**
* Full control over `MeshService`, no magic.

**Disadvantage**
* Breaks existing flow if we eventually drop `kuma.io/service`
* Extra steps for Service owners. You need to handle RBAC for Zone CP access or go through gitops

### `MeshService` autogenerated explicitly

We can introduce `MeshServiceGenerator` object that would help to autogenerate `MeshService`.

```yaml
type: MeshServiceGenerator
name: univesral
spec:
  targetRef:
    kind: MeshSubset
    tags: # you can select subset of proxies
      x: xyz
  template:
    name: {{ tag "kuma.io/service" }}
    export:
      mode: All # or for example {{ tag "kuma.io/export-mode" }}
    selector:
      tags:
        kuma.io/service: {{ tag "kuma.io/service" }}
    ports:
      port: {{ port }}
      targetPort: {{ servicePort }}
      protocol: {{ tag "kuma.io/protocol" }}
```

so that given this `Dataplane` object

```yaml
type: Dataplane
mesh: default
name: dp-01
networking:
  inbound:
    - port: 11011
      servicePort: 11012
      tags:
        kuma.io/service: backend-web
        kuma.io/protocol: http
        kuma.io/export-mode: All
    - port: 11013
      servicePort: 11014
      tags:
        kuma.io/service: backend-api
        kuma.io/protocol: grpc
```

We would generate the following MeshServices

```yaml
type: MeshService
name: backend-web
labels:
  kuma.io/generated-by: universal
spec:
  export:
    mode: All
  selector:
    tags:
      kuma.io/service: backend-web
  ports:
  - port: 11011 # from port
    targetPort: 11012 # from servicePort
    protocol: http
---
type: MeshService
name: backend-api
labels:
  kuma.io/generated-by: universal
spec:
  selector:
    tags:
      kuma.io/service: backend-api
  ports:
  - port: 11013 # from port
    targetPort: 11014 # from servicePort
    protocol: grpc
```

**How to name autogenerated mesh services**
Name of the object has such regex `^[0-9a-z.\-_]*$`, while value of `kuma.io/service` has such regex `^[a-zA-Z0-9.\-_:]*$`.
Name regex is more restrictive so in some cases we may not be able to autogenerate MeshService. We should log error, so user can eventually correct this.
It's rather unlikely to have `A-Z` and `:` in `kuma.io/service` value, so it shouldn't be a significant problem.

**Advantages**
* We keep the same flow without any extra action from the user
* Flexibility for users to define their own template

**Disadvantages***
* Complexity of implementing this object

### `MeshService` autogenerated implicitly

Instead of introducing explicit `MeshServiceGenerator` we can just have opinionated process just like Service -> MeshService on Kube.

Fields we would generate:
* name - value of `kuma.io/service` tag
* selector.dataplane.tags - `kuma.io/service` key + value
* export.mode - value of `kuma.io/export-mode` tag
* port - `networking.inbound[*].port`
* targetPort - `networking.inbound[*].servicePort` or fallback to `networking.inbound[*].port`
* protocol - value of `kuma.io/protocol` tag

**Advantages**
* We keep the same flow without any extra action from the user

**Disadvantages***
* Less customization options
